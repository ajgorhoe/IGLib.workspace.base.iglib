using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.IO;
using System.IO.Pipes;
using System.Threading;


namespace IG.Lib
{
    
    /* See:
     * http://stackoverflow.com/questions/1309062/bidirectional-named-pipe-question
     * http://msdn.microsoft.com/en-us/library/bb546085%28v=vs.110%29.aspx
     */



    /// <summary>Base class for named pipe serverrs and clients, contains common stuff for both.</summary>
    public abstract class NamedPipeServerClientBase : ILockable
    {

        /// <summary>Provides an answer string to the specified request string.</summary>
        /// <param name="request">Request string.</param>
        /// <returns>Answer to the request.</returns>
        public delegate string ResponseDelegate(string request);



        #region Data.General

        private static object _lockGlobal = null;

        /// <summary>Static lock object used by all instances of this class (and possibly by other classes).</summary>
        public static object LockGlobal
        {
            get
            {
                if (_lockGlobal == null)
                {
                    lock (Util.LockGlobal)
                    {
                        if (_lockGlobal == null)
                            _lockGlobal = new object();
                    }
                }
                return _lockGlobal;
            }
        }


        protected object _lock = new object();

        /// <summary>Objectt for locking the current object.</summary>
        public object Lock { get { return _lock; } }

        private static int _defatultOutputLevel = 1;

        /// <summary>Default level of output for this kind of class.</summary>
        public static int DefaultOutputLevel
        {
            get { lock (LockGlobal) return _defatultOutputLevel; }
            set { lock (LockGlobal) { _defatultOutputLevel = value; } }
        }

        private int _otputLevel = DefaultOutputLevel;

        /// <summary>Level of output generated by operatins.</summary>
        public int OutputLevel
        {
            get { lock (Lock) { return _otputLevel; } }
            set { lock (Lock) { _otputLevel = value; } }
        }

        private static string _defaultPipeName = "IGLibServerPipe";

        /// <summary>Default pipe name.</summary>
        public static string DefaultPipeName
        {
            get { lock (LockGlobal) { return _defaultPipeName; } }
            set
            {
                lock (LockGlobal)
                {
                    if (string.IsNullOrEmpty(value))
                        throw new NullReferenceException("Default pipe name can not be empty or null string.");
                    else
                        _defaultPipeName = value;
                }
            }
        }

        private string _pipeName = DefaultPipeName;

        public string PipeName
        {
            get { lock (_lock) { return _pipeName; } }
            set
            {
                lock (_lock)
                {
                    if (string.IsNullOrEmpty(value))
                        throw new NullReferenceException("Pipe name can not be an empty or null string.");
                    if (value != _pipeName)
                    {
                        _pipeName = value;
                        ClosePipe();
                    }
                }
            }
        }


        #endregion Data.General


        #region Data.Streams


        /// <summary>Closes the pipe and streams that depend on it.</summary>
        public abstract void ClosePipe();
        
        /// <summary>Input stream of the server's named pipe.</summary>
        public abstract StreamReader InputStream { get; protected set; }
        
        /// <summary>Output stream of the server's named pipe.</summary>
        public abstract StreamWriter OutputStream { get; protected set; }

        #endregion Data.Streams


    }  // class NamedPipeServerClientBase
    



    /// <summary>Server that creates a named pipe, listens on its input stream, and sends responses
    /// to the client.</summary>
    /// $A Igor Mar14;
    public class NamedPipeServerBase : NamedPipeServerClientBase, ILockable
    {

        private NamedPipeServerBase()
            : base()
        {  }


        /// <summary>Constructs a new pip server.</summary>
        /// <param name="pipeName">Name of the pipe used for client-server communication.</param>
        public NamedPipeServerBase(string pipeName) : base()
        {
            this.PipeName = pipeName;
        }


        #region Data.Streams

        private NamedPipeServerStream _serverPipe=null;

        /// <summary>Named pipe used for communication by the server.</summary>
        public NamedPipeServerStream Pipe
        {
            get
            {
                lock (_lock)
                {
                    if (_serverPipe == null)
                        _serverPipe = new NamedPipeServerStream(PipeName, PipeDirection.InOut);
                    return _serverPipe;
                }
            }
            protected set
            {
                lock (_lock)
                {
                    if (value != _serverPipe)
                    {
                        if (_serverPipe != null)
                        {
                            _serverPipe.Close();
                        }
                        InputStream = null;
                        OutputStream = null;
                        _serverPipe = value;
                    }
                }
            }
        }

        private StreamReader _inputStream = null;

        /// <summary>Input stream of the server's named pipe.</summary>
        public override StreamReader InputStream
        {
            get
            {
                lock (Lock)
                {
                    if (_inputStream == null)
                    {
                        _inputStream = new StreamReader(Pipe);
                    }
                    return _inputStream;
                }
            }
            protected set
            {
                lock (Lock)
                {
                    if (value != _inputStream)
                    {
                        if (_inputStream != null)
                        {
                            _inputStream.Close();
                        }
                        _inputStream = value;
                    }
                }
            }
        }


        private StreamWriter _outputStream = null;

        /// <summary>Output stream of the server's named pipe.</summary>
        public override StreamWriter OutputStream
        {
            get
            {
                lock (Lock)
                {
                    if (_outputStream == null)
                    {
                        _outputStream = new StreamWriter(Pipe);
                    }
                    return _outputStream;
                }
            }
            protected set
            {
                lock (Lock)
                {
                    if (value != _outputStream)
                    {
                        if (_outputStream != null)
                        {
                            _outputStream.Close();
                        }
                        _outputStream = value;
                    }
                }
            }
        }

        /// <summary>Closes the Server's pipe and the associated streams.</summary>
        public override void ClosePipe()
        {
            Pipe = null;
        }

        /// <summary>Closes the inpt stream.</summary>
        public void CloseInput()
        {
            InputStream = null;
        }

        /// <summary>Closes the outut stream.</summary>
        public void CloseOutput()
        {
            OutputStream = null;
        }


        #endregion Data.Streams

        #region Data.Operaton

        protected internal bool _isResponseSent = false;

        /// <summary>Auxiliary flag telling whether response to a request has already been sent to the client.
        /// Used for synchronization of diffeeent parts of the response generation process,
        /// which enables e.g special handling of Exceptions.</summary>
        public bool IsResponseSent
        {
            get { lock (Lock) { return _isResponseSent; } }
            protected set { _isResponseSent = value; }
        }

        protected internal bool _isError = false;

        public bool IsError
        {
            get { lock (Lock) { return _isError; } }
            protected set { _isError = true; }
        }


        protected internal string _requestString = null;

        /// <summary>The last request string that was read from the pipe.</summary>
        public string RequestString
        {
            get { lock (_lock) { return _requestString; } }
            protected set { lock (Lock) { _requestString = value; } }
        }

        protected internal string _responseString = null;

        /// <summary>The last answer string that was written to the pipe.</summary>
        public string ResponseString
        {
            get { lock (_lock) { return _responseString; } }
            protected set { lock (Lock) { _responseString = value; } }
        }


        private bool _stopServe = false;

        /// <summary>Whether the pipe should be closed.</summary>
        public bool StopServe
        { get { lock (_lock) { return _stopServe; } } protected set { lock (_lock) { _stopServe = value; } } }


        private static string _defaultStopRequest = "stop";

        /// <summary>Default stop request string - request string that will stop the server.</summary>
        public static string DefaultStopRequest
        {
            get { lock (LockGlobal) { return _defaultStopRequest; } }
            set
            {
                lock (LockGlobal)
                {
                    //if (string.IsNullOrEmpty(value))
                    //    throw new NullReferenceException("Default stop request can not be empty or null string.");
                    //else
                    _defaultStopRequest = value;
                }
            }
        }


        private string _stopRequest = DefaultStopRequest;

        /// <summary>Request the causes the server stop listening and closing the pipe.</summary>
        public string StopRequest
        {
            get { lock (Lock) { return _stopRequest; } }
            set { _stopRequest = value; }
        }


        private static string _defaultGenericResponse = "IGLib_PipeServer_GenericResponse";

        /// <summary>Default generic response (sent in absence of any other method to generate the request).</summary>
        public static string DefaultGenericResponse
        {
            get { lock (LockGlobal) { return _defaultGenericResponse; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultErrorResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Default generic response of pipe server can not be empty or null string.");
                        else
                        {
                            if (DefaultOutputLevel >= 1)
                                Console.WriteLine(Environment.NewLine + "Warning: default generic response of pipe servers changed: "
                                    + Environment.NewLine + "  from " + _defaultGenericResponse + " to " + value + ".");
                            _defaultGenericResponse = value;
                        }
                    }
                }
            }
        }

        private string _genericResponse = DefaultGenericResponse;

        /// <summary>Generic response that is sent back to the client in abscence of any
        /// method generating responses to specific requests.</summary>
        public string GenericResponse
        {
            get { lock (_lock) { return _genericResponse; } }
            protected set
            {
                lock (_lock)
                {
                    if (value != _genericResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe server's generic response can not be an empty or null string.");
                        _genericResponse = value;
                    }
                }
            }
        }


        private static string _defaultStoppedResponse = "IGLib_PipeServer_StoppedResponse";

        /// <summary>Default stopped response (sent after the srver has sttopped on request).</summary>
        public static string DefaultStoppedResponse
        {
            get { lock (LockGlobal) { return _defaultStoppedResponse; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultErrorResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Default generic response of pipe server can not be empty or null string.");
                        else
                        {
                            if (DefaultOutputLevel >= 1)
                                Console.WriteLine(Environment.NewLine + "Warning: default stopped response of pipe servers changed: "
                                    + Environment.NewLine + "  from " + _defaultStoppedResponse + " to " + value + ".");
                            _defaultStoppedResponse = value;
                        }
                    }
                }
            }
        }

        private string _stoppedResponse = DefaultStoppedResponse;

        /// <summary>Stopped response that is sent back to the client after the server stops on its
        /// request.</summary>
        public string StoppedResponse
        {
            get { lock (_lock) { return _stoppedResponse; } }
            protected set
            {
                lock (_lock)
                {
                    if (value != _stoppedResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe server's stopped response can not be an empty or null string.");
                        _stoppedResponse = value;
                    }
                }
            }
        }


        private static string _defaultErrorResponse = "IGLib_PipeServer_ErrorResponse";

        /// <summary>Default error response (sent as response when exception is thrown in the process of 
        /// response generation).</summary>
        public static string DefaultErrorResponse
        {
            get { lock (LockGlobal) { return _defaultErrorResponse; } }
            protected set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultErrorResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe servers' default error response can not be empty or null string.");
                        else
                        {
                            if (DefaultOutputLevel > 0)
                                Console.WriteLine(Environment.NewLine + "Default error response of pipe servers has changed: "
                                    + Environment.NewLine + "  from " + _defaultErrorResponse + " to " + value + ".");
                            _defaultErrorResponse = value;
                        }
                    }
                }
            }
        }


        private string _errorResponse = DefaultErrorResponse;

        /// <summary>Response that is sent to the client in case of exception.</summary>
        public string ErrorResponse
        {
            get { lock (_lock) { return _errorResponse; } }
            protected set
            {
                lock (_lock)
                {
                    if (value != _errorResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe server's error response can not be an empty or null string.");
                        _errorResponse = value;
                    }
                }
            }
        }

        #endregion Data.Operaton



        #region Data.SavedState


        protected internal Exception _lastException = null;

        /// <summary>Returns the last exception thrown when serving request.</summary>
        public Exception LastException
        {
            get { lock (Lock) { return _lastException; } }
            protected set { lock (Lock) { _lastException = value; } }
        }


        protected internal string _lastErrorMessage = null;

        /// <summary>Returns the last error message.</summary>
        public string LastErrorMessage
        {
            get { lock (Lock) { return _lastErrorMessage; } }
            protected set { lock (Lock) { _lastErrorMessage = value; } }
        }


        protected internal string _lastRequestString = null;

        /// <summary>Returns the last request string.</summary>
        public string LastRequestString
        {
            get { lock (Lock) { return _lastRequestString; } }
            protected set { lock (Lock) { _lastRequestString = value; } }
        }


        protected internal string _lastResponseString = null;

        /// <summary>Returns the last response string.</summary>
        public string LastResponseString
        {
            get { lock (Lock) { return _lastResponseString; } }
            protected set { lock (Lock) { _lastResponseString = value; } }
        }

        #endregion Data.SavedState


        #region Operation.ResponseDefinition
        

        /// <summary>The deefault method that returns response to the specified request.
        /// <para>Just returns a string that tells which was the request string.</para></summary>
        /// <param name="request"></param>
        /// <returns></returns>
        protected static string DefaultResponseMethod(string request)
        {
            return "Request: \" " + request + "\"";
        }

        private ResponseDelegate _responseMethod = DefaultResponseMethod;

        /// <summary>Delegate that calculates response to given request.</summary>
        public ResponseDelegate ResponseMethod
        {
            get { lock (Lock) { return _responseMethod; } }
            set { lock (Lock) { _responseMethod = value; } }
        }


        /// <summary>Returns response string for given request string.</summary>
        /// <param name="request">The request string.</param>
        /// <returns>Response to the request string.</returns>
        public virtual string GetResponse(string request)
        {
            if (ResponseMethod != null)
            {
                return ResponseMethod(request);
            }
            else
            {
                return GenericResponse;
            }
        }

        /// <summary>Returns error message corresponding to the specified exception.</summary>
        /// <param name="ex"></param>
        protected virtual string GetErrorMessage(Exception ex)
        {
            if (ex == null)
                return "ERROR. Cause unknown.";
            else
                return "ERROR - " + ex.GetType() + ": " + ex.Message;
        }

        #endregion Operation.ResponseDefinition


        #region Operation

        /// <summary>Reads the next request from the pipe.</summary>
        public virtual void ReadRequest()
        {
            lock (Lock)
            {
                _requestString = InputStream.ReadLine();
                _lastRequestString = _requestString;
                _isResponseSent = false;
                _responseString = null;
                _isError = false;
                _lastException = null;
                _lastErrorMessage = null;
            }
        }

        /// <summary>Sends the specified response string back to the server.</summary>
        /// <param name="responseString"></param>
        public virtual void SendResponse(string responseString)
        {
            lock (Lock)
            {
                OutputStream.WriteLine(responseString);
                _isResponseSent = true;
                _lastResponseString = responseString;
            }
        }

        /// <summary>Sends the response (i.e., the <see cref="ResponseString"/>) back to the client.</summary>
        public virtual void SendResponse()
        {
            SendResponse(this._responseString);
        }

        /// <summary>Gets answer to the request and writes it to the pipe.</summary>
        public virtual void RespondToRequest()
        {
            lock (Lock)
            {
                ReadRequest();
                if (OutputLevel >= 2)
                {
                    Console.WriteLine(Environment.NewLine +
                        "Request: \"" + RequestString + "\"");
                }
                ResponseString = GetResponse(RequestString);
                if (OutputLevel >= 2)
                {
                    Console.WriteLine("Response: \"" + ResponseString + "\"");
                }

                if (!string.IsNullOrEmpty(RequestString))
                {
                    // Verify special requests with pre-defined meaning, such as stop server request:
                    if (StopRequest == RequestString)
                    {
                        StopServe = true;
                        SendResponse(StoppedResponse);
                        if (OutputLevel >= 1)
                        {
                            Console.WriteLine(Environment.NewLine + "Stop request sent, server is stopping." + Environment.NewLine
                                + "  Request sting: " + RequestString);
                        }
                    }
                }
                if (!_isResponseSent)
                {
                    SendResponse();
                }

            }
        }


        /// <summary>Enters the serving loop.
        /// <remarks>Within the loop, only <see cref="ReadRequest"/>() and <see cref="RespondToRequest"/>()
        /// are executed. The latter must handle things like stopping requests.</remarks></summary>
        public virtual void Serve()
        {
            StopServe = false;
            while (!StopServe)
            {
                lock (_lock)
                {
                    try
                    {
                        ReadRequest();
                        RespondToRequest();
                    }
                    catch (Exception ex)
                    {
                        _isError = true;
                        _lastException = ex;
                        _lastErrorMessage = GetErrorMessage(ex);
                        if (!_isResponseSent)
                            SendResponse(ErrorResponse);
                    }
                }
            }
            // After the server stops listneing, reset its state:
            IsResponseSent = false;
            IsError = false;
            RequestString = null;
            ResponseString = null;
            LastRequestString = null;
            LastResponseString = null;
            LastException = null;
            LastErrorMessage = null;
        }


        #endregion Operation


    } // classs NamedPipeServerBase 



    /// <summary>Client to the pipe server (classes derived from <see cref="NamedPipeServerBase"/>).</summary>
    /// $A Igor Mar14;
    public class NamedPipeClientBase : NamedPipeServerClientBase, ILockable
    {

        public NamedPipeClientBase() : base()
        { }


        #region Data.General


        private static string _defaultServerSddress = ".";

        /// <summary>Default server address.
        /// Setting to null sets it to "." (i.e. the local machine).</summary>
        public static string DefaultServerAddress
        {
            get { lock (LockGlobal) { return _defaultServerSddress; } }
            set
            {
                lock (LockGlobal)
                {
                    if (string.IsNullOrEmpty(value))
                        _defaultServerSddress = ".";
                    else
                        _defaultServerSddress = value;
                }
            }
        }

        private string _serverAddress = DefaultServerAddress;

        public string ServerAddress
        {
            get { lock (_lock) { return _serverAddress; } }
            set
            {
                lock (_lock)
                {
                    if (string.IsNullOrEmpty(value))
                        value=DefaultServerAddress;
                    if (value != _serverAddress)
                    {
                        _serverAddress = value;
                        ClosePipe();
                    }
                }
            }
        }


        #endregion Data.General

        #region Data.Streams

        private NamedPipeClientStream _serverPipe = null;

        /// <summary>Named pipe used for communication by the server.</summary>
        public NamedPipeClientStream Pipe
        {
            get
            {
                lock (_lock)
                {
                    if (_serverPipe == null)
                        _serverPipe = new NamedPipeClientStream(ServerAddress, PipeName, PipeDirection.InOut);
                    return _serverPipe;
                }
            }
            protected set
            {
                lock (_lock)
                {
                    if (value != _serverPipe)
                    {
                        if (_serverPipe != null)
                        {
                            _serverPipe.Close();
                        }
                        InputStream = null;
                        OutputStream = null;
                        _serverPipe = value;
                    }
                }
            }
        }

        private StreamReader _inputStream = null;

        /// <summary>Input stream of the server's named pipe.</summary>
        public override StreamReader InputStream
        {
            get
            {
                lock (Lock)
                {
                    if (_inputStream == null)
                    {
                        _inputStream = new StreamReader(Pipe);
                    }
                    return _inputStream;
                }
            }
            protected set
            {
                lock (Lock)
                {
                    if (value != _inputStream)
                    {
                        if (_inputStream != null)
                        {
                            _inputStream.Close();
                        }
                        _inputStream = value;
                    }
                }
            }
        }


        private StreamWriter _outputStream = null;

        /// <summary>Output stream of the server's named pipe.</summary>
        public override StreamWriter OutputStream
        {
            get
            {
                lock (Lock)
                {
                    if (_outputStream == null)
                    {
                        _outputStream = new StreamWriter(Pipe);
                    }
                    return _outputStream;
                }
            }
            protected set
            {
                lock (Lock)
                {
                    if (value != _outputStream)
                    {
                        if (_outputStream != null)
                        {
                            _outputStream.Close();
                        }
                        _outputStream = value;
                    }
                }
            }
        }

        /// <summary>Closes the Server's pipe and the associated streams.</summary>
        public override void ClosePipe()
        {
            Pipe = null;
        }

        /// <summary>Closes the inpt stream.</summary>
        public void CloseInput()
        {
            InputStream = null;
        }

        /// <summary>Closes the outut stream.</summary>
        public void CloseOutput()
        {
            OutputStream = null;
        }

        #endregion Data.Streams


        #region  Operation




        #endregion Operation



    } // class NamedPipeClientBase




}

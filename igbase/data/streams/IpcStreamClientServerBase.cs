// Copyright (c) Igor Grešovnik (2008 - present), IGLib license; http://www2.arnes.si/~ljc3m2/igor/iglib/

// Base classes for client/server based on streamed communication 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.IO;
using System.IO.Pipes;
using System.Threading;


namespace IG.Lib
{

    public enum IpcStage {
        WritingRequest, 
        ReadingRequest,
        WritingResponse,
        ReadingResponse
    }

    /// <summary>Base class for client and server classes with stream-based communication.</summary>
    /// $A Igor xx Aug14;
    public abstract class IpcStreamClientServerBase : ILockable
    {


        /// <summary>Provides an answer string to the specified request string.</summary>
        /// <param name="request">Request string.</param>
        /// <returns>Answer to the request.</returns>
        public delegate string ResponseDelegate(string request);


        #region ThreadLocking

        protected object _lock = new object();

        /// <summary>Objectt for locking the current object.</summary>
        public object Lock { get { return _lock; } }


        private static object _lockGlobal = null;

        /// <summary>Static lock object used by all instances of this class (and possibly by other classes).</summary>
        public static object LockGlobal
        {
            get
            {
                if (_lockGlobal == null)
                {
                    lock (Util.LockGlobal)
                    {
                        if (_lockGlobal == null)
                            _lockGlobal = new object();
                    }
                }
                return _lockGlobal;
            }
        }


        #endregion ThreadLocking 

        
        #region Data.General


        private StringBuilder _sb = new StringBuilder();

        protected StringBuilder StringBuilderInternal
        {
            get { return _sb; }
        }


        private static int _defatultOutputLevel = 1;



        /// <summary>Default level of output for this kind of class.</summary>
        public static int DefaultOutputLevel
        {
            get { lock (LockGlobal) return _defatultOutputLevel; }
            set { lock (LockGlobal) { _defatultOutputLevel = value; } }
        }

        private int _otputLevel = DefaultOutputLevel;

        /// <summary>Level of output generated by operatins.</summary>
        public virtual int OutputLevel
        {
            get { lock (Lock) { return _otputLevel; } }
            set { lock (Lock) { _otputLevel = value; } }
        }


        #endregion Data.General


        #region Messages.General

        public const int MinimalMessagePreffixLength = 3;

        private static string _defaultMessagePrefix = "IGLibMsg";

        public static string DefaultMessagePrefix
        {
            get { lock(LockGlobal) { return _defaultMessagePrefix; } }
            set {
                lock(LockGlobal)
                {
                    if (value != _defaultMessagePrefix)
                    {
                        if (string.IsNullOrEmpty(value))
                        {
                            throw new ArgumentException("New default value for message prefix is not specified (null or empty string).");
                        } else if (value.Length < MinimalMessagePreffixLength)
                        {
                            throw new ArgumentException("Length of default value for message prefix is too short, should be at least "
                                + MinimalMessagePreffixLength + " haracters long.");
                        } else
                        {
                            _defaultMessagePrefix = value;
                        }
                    }
                }
            }
        }

        private static char _defaultMessageSeparator = '_';

        public static char DefaultMessageSeparator
        {
            get { lock (LockGlobal) { return _defaultMessageSeparator; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultMessageSeparator)
                    {
                        if (char.IsSeparator(value) || char.IsWhiteSpace(value))
                            throw new ArgumentException("Invalid default message separator '" + value + "': may not be separator or whitespace.");
                        else if (value == DefaultMessageFalseSeparator)
                            throw new ArgumentException("Invalid default message separator '" + value + "': can not be the same as false separator.");
                        else _defaultMessageSeparator = value;
                    }
                }
            }
        }

        private static char _defaultMessageFalseSeparator = '.';

        public static char DefaultMessageFalseSeparator
        {
            get { lock (LockGlobal) { return _defaultMessageFalseSeparator; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultMessageFalseSeparator)
                    {
                        if (char.IsSeparator(value) || char.IsWhiteSpace(value))
                            throw new ArgumentException("Invalid default false message separator '" + value + "': may not be separator or whitespace.");
                        else if (value == DefaultMessageSeparator)
                            throw new ArgumentException("Invalid default false message separator '" + value + "': can not be the same as separator.");
                        else _defaultMessageFalseSeparator = value;
                    }
                }
            }
        }
        
        
        private string _messagePrefix = DefaultMessagePrefix;


        public string MessagePrefix
        {
            get { lock (Lock) { return _messagePrefix; } }
            protected set
            {
                lock (Lock)
                {
                    if (value != MessagePrefix)
                    {
                        if (string.IsNullOrEmpty(value))
                        {
                            throw new ArgumentException("New message prefix is not specified (null or empty string).");
                        }
                        else if (value.Length < MinimalMessagePreffixLength)
                        {
                            throw new ArgumentException("Length of message prefix is too short, should be at least "
                                + MinimalMessagePreffixLength + " characters long.");
                        } else
                        {
                            // Invalidate combined message prefix and separator:
                            MessagePrefixWithSeparator = null;
                            _messagePrefix = value;
                        }

                    }
                }
            }
        }

        /// <summary>Changes message prefix for the current object.
        /// <para>This setter method is provided in order to keep the <see cref="MessagePrefix"/> setter protected.</para></summary>
        /// <param name="messagePrefix">New message prefix. Must be at least <see cref="MinimalMessagePreffixLength"/> characters long.</param>
        public void SetMessagePreix(string messagePrefix)
        {
            MessagePrefix = messagePrefix;
        }

        private char _messageSeparator = DefaultMessageSeparator;

        public char MessageSeparator
        {
            get { lock (Lock) { return _messageSeparator; } }
            protected set {
                lock (Lock)
                {
                    if (value != _messageSeparator)
                    {
                        if (char.IsSeparator(value) || char.IsWhiteSpace(value))
                            throw new ArgumentException("Invalid message separator '" + value + "': may not be separator or whitespace.");
                        else if (value == MessageFalseSeparator)
                            throw new ArgumentException("Invalid message separator '" + value + "': may not be the same as false separator.");
                        else
                        {
                            // Invalidate combined message prefix and separator:
                            MessagePrefixWithSeparator = null;
                            _messageSeparator = value;
                        }
                    }
                }
            }
        }

        /// <summary>Changes message separator for the current object.
        /// <para>This setter method is provided in order to keep the <see cref="MessageSeparator"/> setter protected.</para></summary>
        /// <param name="messagePrefix">New message separator must not be a separator or a white space character.</param>
        public void SetMessageSeparator(char messageSeparator)
        {
            MessageSeparator = messageSeparator;
        }



        private char _messageFalseSeparator = DefaultMessageFalseSeparator;

        public char MessageFalseSeparator
        {
            get { lock (Lock) { return _messageFalseSeparator; } }
            protected set
            {
                lock (Lock)
                {
                    if (value != _messageFalseSeparator)
                    {
                        if (char.IsSeparator(value) || char.IsWhiteSpace(value))
                            throw new ArgumentException("Invalid message false separator '" + value + "': may not be separator or whitespace.");
                        else if (value == MessageSeparator)
                            throw new ArgumentException("Invalid message false separator '" + value + "': may not be the same as separator.");
                        else 
                        {
                            _messageFalseSeparator = value;
                        }
                    }
                }
            }
        }

        /// <summary>Changes message false separator for the current object.
        /// <para>This setter method is provided in order to keep the <see cref="MessageFalseSeparator"/> setter protected.</para></summary>
        /// <param name="messagePrefix">New message false separator must not be a separator or a white space character.</param>
        public void SetMessageFalseSeparator(char messageFalseSeparator)
        {
            MessageFalseSeparator = messageFalseSeparator;
        }



        private string _messagePrefixWithSeparator = null;

        /// <summary>Gets the mesage prefix with separator. If some string is a message, everything that follows this string
        /// until the first separator is a message name.
        /// <para>A protected getter is defined that is only allowed to set the property to null (invalidate it). If a
        /// non-null value is set then an exception is thrown.</para></summary>
        public string MessagePrefixWithSeparator
        {
            get
            {
                lock (Lock)
                {
                    if (_messagePrefixWithSeparator == null)
                    {
                        _messagePrefixWithSeparator = MessagePrefix + MessageSeparator;
                    }
                    return _messagePrefixWithSeparator;
                }
            }
            protected set
            {
                if (value != null)
                    throw new InvalidOperationException("Message separator with prefix can only be set to null.");
                else
                    _messagePrefixWithSeparator = value;
            }
        }


        /// <summary>Creates a built-in message (possibly with arguments) that is to be interpreted directly by the receiver 
        /// (stream client or server) and is not executed via ordinary path.
        /// <para>Messages commands are composed of message prefix, separator (jointly <see cref="MessagePrefixWithSeparator"/>), 
        /// and message name. The first two are fixed parts whire the latter varies and defines the message.</para></summary>
        /// <param name="messageName">Name of the message (a kind of command name).</param>
        /// <param name="messageArguments">Optional arguments of the message.</param>
        /// <returns></returns>
        public string CreateMessage(string messageName, string[] messageArguments)
        {
            lock (Lock)
            {
                StringBuilder sb = StringBuilderInternal;
                sb.Clear();
                sb.Append(MessagePrefixWithSeparator);
                sb.Append(messageName);
                if (messageArguments != null)
                {
                    int num = messageArguments.Length;
                    for (int i = 0; i < num; ++i)
                    {
                        sb.Append(" ");
                        string str = messageArguments[i];
                        if (str.Contains('\n') || str.Contains('\r'))
                            throw new InvalidOperationException("Message argument contains newline characters.");
                        sb.Append(messageArguments[i]);
                    }
                }
                return sb.ToString();
            }
        }

        /// <summary>Generates request and response string in such a way that it can not be mixed up with a message.
        /// <para>If the original string begins with the message prefix theen a false separator is inserted after the part that
        /// is the same as message prefix. In this way the string can be distinguished form a message and can be correctly decoded
        /// on the other side of the communication pipeline (simply by removng the false separator).</para></summary>
        /// <param name="originalResponseOrRequestString">Original response string that is sent to the other side.</param>
        /// <returns>The created request string that can be distinguished form a command.</returns>
        public string CreateResponseOrRequestString(string originalResponseOrRequestString, bool multiLine)
        {
            if (originalResponseOrRequestString == null)
                return null;
            else
            {
                string ret = null;
                if (!originalResponseOrRequestString.StartsWith(MessagePrefix))
                    ret = originalResponseOrRequestString;
                else 
                    ret = MessagePrefix + MessageFalseSeparator + originalResponseOrRequestString.Substring(MessagePrefix.Length);
                if (!multiLine)
                    ret = ret.Replace("\n", "\\n").Replace("\r","\\r");
                return ret;
            }
        }

        /// <summary>Returns the (eventually decoded) request or response string corresponding to the stirng that is read form the 
        /// communication pipeline, and also parameters that specify whether the request string represents a message or not. Eventual
        /// command or message parameters are also returned.</summary>
        /// <param name="responseOrRequestString">Original response or request string that is to be decoded.</param>
        /// <param name="isMessage">Output flag telling whether the string is a message or not.</param>
        /// <param name="messageOrCommandName">Name of the message or command extracted from the string.</param>
        /// <param name="messageArguments">Message or command arguments.</param>
        public void InterpretRequestOrResponseLine(ref string responseOrRequestString, out bool isMessage, 
            out string messageOrCommandName, out string [] messageArguments)
        {
            isMessage = false;
            messageOrCommandName = null;
            messageArguments = null;
            if (responseOrRequestString != null)
            {
                if (responseOrRequestString.StartsWith(MessagePrefix))
                {
                    if (responseOrRequestString.StartsWith(MessagePrefixWithSeparator))
                    {
                        // String is actually a message:
                        isMessage = true;
                        responseOrRequestString = responseOrRequestString.Substring(MessagePrefixWithSeparator.Length);
                        string[] parts = responseOrRequestString.Split(new char[] {' ', '\t', '\r', '\n'}, StringSplitOptions.RemoveEmptyEntries);
                        messageOrCommandName = parts[0];
                        int numParts = parts.Length;
                        if (numParts > 1)
                        {
                            messageArguments = new string[numParts - 1];
                            for (int i = 1; i < numParts; ++i)
                                messageArguments[i-1] = parts[i];
                        }
                    } else
                    {
                        // String begins with message prfix, but it is not a message (because a separator is not following):
                        // Actual request/response string is obtained by excluding the inserted additional character after the MessagePrefix:
                        responseOrRequestString = MessagePrefix + responseOrRequestString.Substring(MessagePrefix.Length + 1);
                    }
                }
            }
        }


        /// <summary>Writes a mesage to the output stream. What is written is decorated message (including the standard message
        /// prefix and separator) and message arguments.</summary>
        /// <param name="outputStream">Stream where the message is written to.</param>
        /// <param name="message">Message name. The name is decorated with prefix and separator when message is written to a stream.</param>
        /// <param name="args">Arguments of the message. Can be null for message without arguments.</param>
        public void writeMessage(StreamWriter outputStream, string message, string[] args)
        {
            if (message.Contains('\n'))
                throw new InvalidDataException("Invalid message name: contains newlines.");
            outputStream.Write(MessagePrefix);
            outputStream.Write(MessageSeparator);
            outputStream.Write(message);
            if (args != null)
            {
                int numArgs = args.Length;
                for (int i = 0; i < numArgs; ++i)
                {
                    string argStr = args[i];
                    if (string.IsNullOrEmpty(argStr))
                        outputStream.Write("  \"\"");
                    else
                    {
                        if (argStr.Contains('\n'))
                            throw new InvalidDataException("Invalid message argument No. " + i + ": contains newlines.");
                        outputStream.Write(" ");
                        outputStream.Write(argStr);
                    }
                }
            }
            outputStream.WriteLine();
        }


        #endregion Messages.General


        public virtual void WorkMessage(string messageName, string[] messageArguments, IpcStage context, ref bool worked)
        {

        }



        #region Messages


        private static string _defaultMsgRequestBegin = "RequestBegin";

        /// <summary>Default message that begins any mulltiline request.</summary>
        public static string DefaultMsgRequestBegin
        {
            get { return _defaultMsgRequestBegin; }
        }

        private static string _defaultMsgRequestEnd = "RequestEnd";

        /// <summary>Default message that ends any mulltiline request.</summary>
        public static string DefaultMsgRequestEnd
        {
            get { return _defaultMsgRequestEnd; }
        }

        private static string _defaultMsgResponseBegin = "ResponseBegin";

        /// <summary>Default message that begins any multiline response.</summary>
        public static string DefaultMsgResponseBegin
        {
            get { return _defaultMsgResponseBegin; }
        }

        private static string _defaultMsgResponseEnd = "ResponseEnd";

        /// <summary>Default message that ends any multiline response.</summary>
        public static string DefaultMsgResponseEnd
        {
            get { return _defaultMsgResponseEnd; }
        }



        private static string _defaultMsgTestSquare = "TestStuare";

        /// <summary>Default message that requests a test computation of square to be performed on the other side (a sort of ping command).</summary>
        public static string DefaultMsgTestSquare
        {
            get { return _defaultMsgTestSquare; }
        }

        private static string _defaultMsgTestSpeed = "TestSpeed";

        /// <summary>Default message that requests a speed test to be performed on the other side (a sort of ping command).</summary>
        public static string DefaultMsgTestSpeed
        {
            get { return _defaultMsgTestSpeed; }
        }


        /// <summary>Message that begins any multiline request (only when multiline requests are allowed).</summary>
        private string _msgRequestBegin = DefaultMsgRequestBegin;

        public string MsgRequestBegin
        {
            get { return _msgRequestBegin; }
            protected set { _msgRequestBegin = value; }
        }

        /// <summary>Message that ends any multiline request (only when multiline requests are allowed).</summary>
        private string _msgRequestEnd = DefaultMsgRequestEnd;

        public string MsgRequestEnd
        {
            get { return _msgRequestEnd; }
            protected set { _msgRequestEnd = value; }
        }


        private string _msgResponseBegin = DefaultMsgResponseBegin;

        /// <summary>Message that begins any multiline response (only when multiline responses are allowed).</summary>
        public string MsgResponseBegin
        {
            get { return _msgResponseBegin; }
            protected set { _msgResponseBegin = value; }
        }

        private string _msgResponseEnd = DefaultMsgResponseEnd;

        /// <summary>Message that ends any multiline response (only when multiline responses are allowed).</summary>
        public string MsgResponseEnd
        {
            get { return _msgResponseEnd; }
            protected set { _msgResponseEnd = value; }
        }


        private string _msgTestSquare = DefaultMsgTestSquare;

        /// <summary>Message that requests square of its argument to be sent back. Used as a kind of verifiable ping.</summary>
        public string MsgTestSquare
        {
            get { return _msgTestSquare; }
            protected set { _msgTestSquare = value; }
        }

        private string _msgTestSpeed = DefaultMsgTestSpeed;

        /// <summary>Message that requires a kind of speed test to be performed on the other side.</summary>
        public string MsgTestSpeed
        {
            get { return _msgTestSpeed; }
            protected set { _msgTestSpeed = value; }
        }

        /// <summary>Responds to a received message.</summary>
        /// <param name="messageName">Name of the message upon which action is taken.</param>
        /// <param name="messageArguments">Arguments of the message.</param>
        /// <param name="responded">Set to true if message has already been responded.</param>
        public virtual void RespondToMessage(string messageName, string[] messageArguments, ref bool responded)
        {
            // base.RespondToMessage(messageName, messageArguments, ref responded);
            switch (messageName)
            {
                default:
                    break;
            }
        }

        #endregion Messages







        #region Messages.Old



        private static string _defaultStopRequest = "stop";

        /// <summary>Default stop request string - request string that will stop the server.</summary>
        public static string DefaultStopRequest
        {
            get { lock (LockGlobal) { return _defaultStopRequest; } }
            set
            {
                lock (LockGlobal)
                {
                    //if (string.IsNullOrEmpty(value))
                    //    throw new NullReferenceException("Default stop request can not be empty or null string.");
                    //else
                    _defaultStopRequest = value;
                }
            }
        }


        private string _stopRequest = DefaultStopRequest;

        /// <summary>Request that causes the server stop listening and closing the pipe.</summary>
        public string StopRequest
        {
            get { lock (Lock) { return _stopRequest; } }
            set { _stopRequest = value; }
        }


        private static string _defaultGenericResponse = "IGLib_PipeServer_GenericResponse";

        /// <summary>Default generic response (sent in absence of any other method to generate the response).</summary>
        public static string DefaultGenericResponse
        {
            get { lock (LockGlobal) { return _defaultGenericResponse; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultGenericResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Default generic response of pipe server can not be empty or null string.");
                        else
                        {
                            if (DefaultOutputLevel >= 1)
                                Console.WriteLine(Environment.NewLine + "Warning: default generic response of pipe servers changed: "
                                    + Environment.NewLine + "  from " + _defaultGenericResponse + " to " + value + ".");
                            _defaultGenericResponse = value;
                        }
                    }
                }
            }
        }

        private string _genericResponse = DefaultGenericResponse;

        /// <summary>Generic response that is sent back to the client in abscence of any
        /// method generating responses to specific requests.</summary>
        public string GenericResponse
        {
            get { lock (_lock) { return _genericResponse; } }
            protected set
            {
                lock (_lock)
                {
                    if (value != _genericResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe server's generic response can not be an empty or null string.");
                        _genericResponse = value;
                    }
                }
            }
        }


        private static string _defaultStoppedResponse = "IGLib_PipeServer_StoppedResponse";

        /// <summary>Default stopped response (sent after the srver has sttopped on request).</summary>
        public static string DefaultStoppedResponse
        {
            get { lock (LockGlobal) { return _defaultStoppedResponse; } }
            set
            {
                lock (LockGlobal)
                {
                    if (value != _defaultStoppedResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Default generic response of pipe server can not be empty or null string.");
                        else
                        {
                            if (DefaultOutputLevel >= 1)
                                Console.WriteLine(Environment.NewLine + "Warning: default stopped response of pipe servers changed: "
                                    + Environment.NewLine + "  from " + _defaultStoppedResponse + " to " + value + ".");
                            _defaultStoppedResponse = value;
                        }
                    }
                }
            }
        }

        private string _stoppedResponse = DefaultStoppedResponse;

        /// <summary>Stopped response that is sent back to the client after the server stops on its
        /// request.</summary>
        public string StoppedResponse
        {
            get { lock (_lock) { return _stoppedResponse; } }
            protected set
            {
                lock (_lock)
                {
                    if (value != _stoppedResponse)
                    {
                        if (string.IsNullOrEmpty(value))
                            throw new NullReferenceException("Pipe server's stopped response can not be an empty or null string.");
                        _stoppedResponse = value;
                    }
                }
            }
        }





        #endregion Messages.Old






        #region Operation.Settings

        private static bool _defaultIsMultilineResponse = true;

        /// <summary>Default pipe name.</summary>
        public static bool DefaultIsMultilineResponse
        {
            get { { return _defaultIsMultilineResponse; } }
        }

        private static bool _defaultIsMultilineRequest = true;

        /// <summary>Default pipe name.</summary>
        public static bool DefaultIsMultilineRequest
        {
            get { { return _defaultIsMultilineRequest; } }
        }

        private bool _isMultilineRequest = DefaultIsMultilineRequest;

        /// <summary>Whether or not multi line requests are allowed.</summary>
        public virtual bool IsMultilineRequest
        {
            get { return _isMultilineRequest; }
            protected set { _isMultilineRequest = value; }
        }


        private bool _isMultilineResponse = DefaultIsMultilineResponse;

        /// <summary>Whether or not multi line responses are allowed.</summary>
        public virtual bool IsMultilineResponse
        {
            get { return _isMultilineResponse; }
            protected set { _isMultilineResponse = value; }
        }

        #endregion Operation.Settings


    }  // class ClienServerStreamBase


} // namespace IG.Lib

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using IG.Lib;

namespace IG.Num
{


    /// <summary>Base class for vector function approximators.</summary>
    public abstract class VectorApproximatorBase: ILockable
    {


        #region ThreadLocking

        private object _mainLock = new object();

        /// <summary>This object's central lock object to be used by other object.
        /// Do not use this object for locking in class' methods, for this you should use 
        /// InternalLock.</summary>
        public object Lock { get { return _mainLock; } }

        #endregion ThreadLocking


        #region Data


        /// <summary>Gets or sets the number of input parameters.</summary>
        public abstract int InputLength
        { get; set; }

        /// <summary>Gets or sets the number of output values.</summary>
        public abstract int OutputLength
        { get; set; }


        #endregion Data


        #region Calculation


        /// <summary>Calculates and returns the approximated outputs corresponding to the specified inputs,
        /// by using the current vector function approximator.</summary>
        /// <param name="input">Input parameters.</param>
        /// <param name="output">Vector where the calculated values are stored.</param>
        /// <returns>Vector of output values generated by the approximator.</returns>
        /// <remarks>Currently, only all outputs at once can be calculated. This makes no difference
        /// in the arrangement with a single network with multiple outputs, but does when several 
        /// networks with single output each are used. If the implementation changes in the future
        /// then performance configuratins should be taken into account carefully, and tracking input
        /// for which input parameters the outputs have been calculated might be necessary.</remarks>
        public abstract void CalculateOutput(IVector input, ref IVector output);

        protected IVector _lastCalculationInputParameters, _lastCalculationOutputValues;

        /// <summary>Calculates and returns the specified output by using the current vector function approximator.</summary>
        public virtual double CalculateOutput(IVector input, int whichElement)
        {
            lock(Lock)
            {
                if (input == null)
                    throw new ArgumentException("Vector of input parameters is not specified when calculating approximated output (null reference).");
                if (input.Length!=InputLength)
                    throw new ArgumentException("Vector of input parameters is of wrong dimension when calculating approximated output ("
                        + input.Length + " instead of " + InputLength + ".");
                if (whichElement < 0 || whichElement>=OutputLength)
                {
                    throw new ArgumentException("Output element index out of range when calculating approximated output ("
                        + whichElement + ", should be between 0 and " + (OutputLength-1).ToString() + ".");
                }
                if (Vector.Compare(input, _lastCalculationInputParameters)!=0)
                {
                    // Calculate vector of output values if not yet calculated: 
                    Vector.Copy(input, ref _lastCalculationInputParameters);  // store input parameters first
                    CalculateOutput(_lastCalculationInputParameters, ref _lastCalculationOutputValues);
                }
                return _lastCalculationOutputValues[whichElement];
            }
        }

        /// <summary>Calculates and returns the required output values corresponding to the specified inputs,
        /// by using the current vector function approximator.</summary>
        /// <param name="input">Input parameters for which output values are calculated.</param>
        /// <param name="indices">Array of indices of the output values to be returned.</param>
        /// <param name="filteredOutput">Vector where filtered output values are stored.</param>
        public virtual void CalculateOutput(IVector input, int[] indices, ref IVector filteredOutput)
        {
            lock (Lock)
            {
                if (input == null)
                    throw new ArgumentException("Vector of input parameters is not specified when calculating approximated output (null reference).");
                if (input.Length != InputLength)
                    throw new ArgumentException("Vector of input parameters is of wrong dimension when calculating approximated output ("
                        + input.Length + " instead of " + InputLength + ".");
                if (indices == null)
                {
                    throw new ArgumentException("Output element indices for which approximation should be calculated are not specified (null reference).");
                    // filteredOutput = null;
                }
                for (int i = 0; i < indices.Length; ++i)
                {
                    int whichElement = indices[i];
                    if (whichElement < 0 || whichElement >= OutputLength)
                    {
                        throw new ArgumentException("Output element index No. " + i + " out of range when calculating approximated output ("
                            + whichElement + ", should be between 0 and " + (OutputLength - 1).ToString() + ".");
                    }
                }
                if (Vector.Compare(input, _lastCalculationInputParameters) != 0)
                {
                    // Calculate vector of output values if not yet calculated: 
                    Vector.Copy(input, ref _lastCalculationInputParameters);  // store input parameters first
                    CalculateOutput(_lastCalculationInputParameters, ref _lastCalculationOutputValues);
                }
                bool resizeRequired = false;
                if (filteredOutput == null)
                    resizeRequired = true;
                else if (filteredOutput.Length != indices.Length)
                {
                    resizeRequired = true;
                }
                if (resizeRequired)
                    Vector.Resize(ref filteredOutput, indices.Length);
                for (int i = 0; i < indices.Length; ++i)
                {
                    filteredOutput[i] =  _lastCalculationOutputValues[indices[i]];
                }
            }
        }


        #endregion Calculation


    }


}

// Copyright (c) Igor Grešovnik (2009 - present), IGLib license; http://www2.arnes.si/~ljc3m2/igor/iglib/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;

using System.Security.Cryptography;

using IG.Lib;

using CC = IG.Crypto.ConstCrypto;
using System.Security.Cryptography.X509Certificates;

namespace IG.Crypto
{

    /// <summary>Performs high level cryptographic opereratins, such ass reading command-line parameters
    /// and performing high-level tasks that can be directly used in application commands (i.e. those commands
    /// that are installed on applicaition interpreters).</summary>
    public class CryptoManager : CryptoParameters
    {

        public CryptoManager()
            : base()
        { }

        public CryptoManager(int outputLevel)
            : base()
        { this.OutputLevel = outputLevel; }

        #region GeneralUtilities

        /// <summary>Used in the current class to report an error.</summary>
        /// <param name="errorString">Error message that is a part of the output generated by this function.</param>
        protected virtual void ReportError(string errorString)
        {
            Console.WriteLine(Environment.NewLine + "ERROR: " + errorString + Environment.NewLine);
        }

        /// <summary>Used in the current class to launch a warning message.</summary>
        /// <param name="errorString">Warning message that is a part of the output generated by this function.</param>
        protected virtual void ReportWarning(string errorString)
        {
            Console.WriteLine(Environment.NewLine + "WARNING: " + errorString + Environment.NewLine);
        }

        /// <summary>Used in the current class to launch an informative message.</summary>
        /// <param name="errorString">Warning message that is a part of the output generated by this function.</param>
        protected virtual void ReportInfo(string errorString)
        {
            Console.WriteLine(Environment.NewLine + "Info: " + errorString + Environment.NewLine);
        }

        ///// <summary>Writes a notification informing that a cryptographic task has been delegated to the <see cref="CryptoParameters"/>
        ///// class.</summary>
        //protected virtual void NotifyAboutCryptoManager()
        //{
        //    Console.WriteLine(Environment.NewLine + Environment.NewLine
        //        + "NOTIFICATION: method called on CRYPROMANAGER (new way) rather than on application class."
        //        + Environment.NewLine + Environment.NewLine );
        //}


        static int _numNotifyPlainEncryption = 0;

        /// <summary>Writes a notification informing that a cryptographic task has been delegated to the <see cref="CryptoParameters"/>
        /// class.</summary>
        protected virtual void WarnAboutPlainEncryption()
        {
            if (_numNotifyPlainEncryption < 1)
            {
                Console.WriteLine(Environment.NewLine + Environment.NewLine
                    + "WARNING: you are using plain encryption routines." + Environment.NewLine
                    + "  Only use the plain encryption routines if you are an encryption expert." + Environment.NewLine
                    + "  Incautious use of plain encryption routines can create security holes."
                    + Environment.NewLine + Environment.NewLine);
                ++_numNotifyPlainEncryption;
            }
        }

        static int _numNotifyExportPrivateKey = 0; 

        /// <summary>Writes a notification informing that a private key may be exported.</summary>
        protected virtual void WarnExportPrivateKey()
        {
            if (_numNotifyExportPrivateKey < 1)
            {
                Console.WriteLine(Environment.NewLine + Environment.NewLine
                    + "WARNING: you are about to export private keys for asymmetric crypto algorithms." + Environment.NewLine
                    + "  Only export private keys if you absolutely know what you are doing." + Environment.NewLine
                    + "  Private keys should usually be guarded carefully."
                    + Environment.NewLine + Environment.NewLine);
                ++_numNotifyExportPrivateKey;
            }
        }


        #endregion GeneralUtilities


        #region Data

        private int _outputLevel = 2;

        /// <summary>Level of output during operation.</summary>
        int OutputLevel { get { return _outputLevel; } set { _outputLevel = value; } }


        // Data deduced from commandline:

        /// <summary>Application name - name of the application when reading from command line.</summary>
        string AppName = null;

        /// <summary>Last (or currently) read command-line arguments.</summary>
        string[] AppArguments = null;

        /// <summary>Number of command-line arguments.</summary>
        int NumAppArguments { get { if (AppArguments != null) return AppArguments.Length;   return 0;   } }


        // ALGORITHM OPTIONS:

        PasswordAlgorithmType PasswordAlgorithmType = PasswordAlgorithmType.Default;
        string PasswordAlgorithmTypeString = null;
        PasswordAlgorithmBase PasswordAlgorithm = null;

        string AlgorithmTypeString = null;

        HashType HashAlgorithmType = HashType.Default;

        SymmetricAlgorithmType SymmetricAlgorithmType = SymmetricAlgorithmType.Default;

        protected bool _isDecrypt = false;

        /// <summary>Whether decryption is perrformed, rather than encryption.</summary>
        public bool IsDecrypt { get { return _isDecrypt; } protected set { _isDecrypt = value; } }

        /// <summary>Whether decryption is perrformed, rather than encryption.</summary>
        public bool IsEncrypt { get { return !IsDecrypt; } protected set { IsDecrypt = !value; } }


        // ASYMMETRIC ALHORITHM OPTIONS:

        private bool _isExportPrivateKey = false;

        /// <summary>Whether private key is also exported or printed.</summary>
        public bool IsExportPrivateKey { get { return _isExportPrivateKey; } 
            protected set { _isExportPrivateKey = value; } }

        private AsymmetricAlgorithmType _asymAlgorithmType = AsymmetricAlgorithmType.Default;

        public AsymmetricAlgorithmType AsymAlgorithmType
        {   get { return _asymAlgorithmType; } 
            protected set { _asymAlgorithmType = value; } }

        private AsymmetricAlgorithm _asymAlgorithm = null;

        /// <summary>Asymmetric algorithm, equipped with keys, that will perform asymmetric cryptographic tasks.</summary>
        protected AsymmetricAlgorithm AsymAlgorithm { get { return _asymAlgorithm; } 
            set { _asymAlgorithm = value; } }

        private CspProviderFlags _asymFlags = CspProviderFlags.NoFlags;

        /// <summary>Asymmetric CSP (crypto service provider) flags.</summary>
        public CspProviderFlags AsymFlags { get { return _asymFlags; }
            set { _asymFlags = CspProviderFlags.NoFlags; } }

        private string _asymAlgorithmTypeString = null;

        /// <summary>String that represents asymmetric algorithm type.</summary>
        public string AsymAlgorithmTypeString { get { return _asymAlgorithmTypeString; } 
            protected set { _asymAlgorithmTypeString = value; } }

        private string _asymKeyContainerName = null;

        /// <summary>Asymmetric key container name.</summary>
        public string AsymKeyContainerName { get { return _asymKeyContainerName; }
            protected set { _asymKeyContainerName = value; }
        }

        private string _asymKeyFileXml = null;

        /// <summary>Asymmetric key file path in XML format.</summary>
        public string AsymKeyFileXml { get { return _asymKeyFileXml; } 
            protected set { _asymKeyFileXml = value; } }

        private string _certificatePath = null;

        /// <summary>Path to the certificate file (e.g. for obtaining asymmetric keys).</summary>
        public string CertificatePath { get { return _certificatePath; } protected set { _certificatePath = value; } }

        private bool _certificatePasswordThroughUi = false;

        /// <summary>Indicates that pasword for private key should obtained from the user through GUI (usually through console).</summary>
        public bool IsCertificatePasswordThroughUi { get { return _certificatePasswordThroughUi; }
            protected set { _certificatePasswordThroughUi = value; }
        }

        private string _certificatePassword = null;

        /// <summary>Password for accessing private keys (e.g. for private keys associated with certificate).</summary>
        protected string CertificatePassword  {  get { return _certificatePassword; }  
            set { _certificatePassword = value; }  }




        // HASHING options:

        string HashValue = null;

        /// <summary>Flag indicating that input are strings or encoded byte arrays, rather than files.</summary>
        bool IsStringInput = false;

        // PASSWORDS, SALTs, KEYs:

        int PasswordLength = 0;
        string PasswordString = null;
        byte[] PasswordBytes = null;

        int SaltLength = 0;
        string SaltString = null;
        byte[] SaltBytes = null;

        int IvLength = 0;
        string IvString = null;
        byte[] IvBytes = null;

        int KeyLength = 0;
        byte[] KeyBytes = null;

        protected bool _isLargestKey = false;

        /// <summary>Whether the largest available key size for the algorithm in use is taken.</summary>
        public bool IsLargestKey { get { return _isLargestKey; } protected set { _isLargestKey = value; } }

        int NumPasswordIterations = 0;

        // List<string> inputFilePaths = new List<string>();


        private List<string> _freeParameters = new List<string>();


        /// <summary>List of free parameters from the parsed command-line.</summary>
        protected List<string> FreeParameters { get { return _freeParameters; } }

        /// <summary>Number of free parameters (obtained from commans-line arguments).</summary>
        public int NumFreeParameters { get { if (FreeParameters != null) return FreeParameters.Count; return 0; } }

        /// <summary>Returns the specified free parameter (obtained from commans-line arguments).</summary>
        /// <param name="whichParameter">Index of the free parameter to be returned.</param>
        public string GetFreeParameter(int whichParameter)
        {
            if (whichParameter < 0 || whichParameter > 0)
                throw new IndexOutOfRangeException("Free parameter index " + whichParameter + " out of range, should be between "
                    + 0 + " and " + (NumFreeParameters - 1));
            return (FreeParameters[whichParameter]);
        }


        // GENERAL OPTIONS:

        string _returnedString = null;

        /// <summary>Returned value of command-line application methods.</summary>
        string ReturnedString { get { return _returnedString; } set { _returnedString = value; } }

        /// <summary>Indicates that something is verified, not calculated (or checked in addition, after calculation).</summary>
        bool IsChecked = false;  // indicates thatsomething is verified, not calculated

        double _targetedTotalTime = 0.1;


        protected double TargetedTotalTime { get { return _targetedTotalTime; } set { _targetedTotalTime = value; }  } 





         

        // FILES: 

        string OutputPath = null;



        List<string> RecursivePathList = new List<string>();
        List<string> RecursivePathListByLevels = new List<string>();
        List<string> RecursiveFilePatterns = new List<string>();
        int RecursiveDirectoryLevels = -1;  // infinite number of levels
        bool IsRelativePaths = false;
        bool IsAbsolutePaths = false;


        /// <summary>Specifies whether the original files should be deleted.
        /// <para>This can refer to deletion of the original file(s) after encryption or decryption, or to 
        /// deletion of the original file in a group(s) of associated files (original, encrypted, decrypted).</para></summary>
        bool IsDeleteOriginal = false;

        /// <summary>Specifies whether the encrypted files should be deleted.
        /// <para>This can refer to deletion of the encrypted file(s) in a group(s) of associated files 
        /// (original, encrypted, decrypted) during a separate clean-up operation.</para></summary>
        bool IsDeleteEncrypted = false;

        /// <summary>Specifies whether the encrypted files should be deleted.
        /// <para>This can refer to deletion of the decrypted file(s) in a group(s) of associated files 
        /// (original, encrypted, decrypted) during a separate clean-up operation.</para></summary>
        bool IsDeleteDecrypted = false;

        /// <summary>Specifies whether all versions of a file (e.g. original, encrypted, and decrypted) are 
        /// allowed to be deleted (e.g. in a file clean-up operation).</summary>
        bool IsDeleteAllVersions = false;

        /// <summary>If true then eventual file overwtires are automatically performed by the 
        /// relevant operation without asking for user's approval.</summary>
        bool IsForceOverwrites = false;

        /// <summary>If true then eventual file overwrites are automatically skipped by the relevant operation.
        /// <para>This means that whenever the operation in question would normally have to overwrite an existent
        /// file, this is skipped, without even asking ro user's approval. For example, if decryption is performed
        /// but some of the original files already exist then these files will not be dcrypted as the operation
        /// would heve to overrwrite the original files.</para></summary>
        bool IsSkipOverwrites = false;

        bool IsForceDeletes = false;

        bool IsSkipDeletes = false;


        // FORMAT OPTIONS:

        /// <summary>If true then options for input formats and output format are treated interchangeably
        /// in the currentt context (e.g. in the current command-line application).</summary>
        bool IsInputFormatEqualOutputFormat = false;

        /// <summary>Whether input format is ordinary string. Returns true if there is no binary
        /// format specified, false if there is.</summary>
        bool IsInputFormatString
        {
            get { return !(IsInputFormatLongInt || IsInputFormat64 || IsInputFormatHex); }
            set
            {
                if (value == true)
                {
                    IsInputFormatLongInt = false;
                    IsInputFormat64 = false;
                    IsInputFormatHex = false;
                }
                else
                {
                    if (!(IsInputFormatLongInt || IsInputFormat64 || IsInputFormatHex))
                        throw new ArgumentException("Input format must be strig where there is no binary format defined.");
                }
            }
        }


        bool _isInputFormatLongInt = false;  // whether input format is a long integer number
        bool _isInputFormat64 = false;
        bool _isInputFormatHex = false;


        public bool IsInputFormatLongInt { get { return _isInputFormatLongInt; } protected set { _isInputFormatLongInt = value; } }

        /// <summary>Whether input is in form of base-64 encoded byte array.</summary>
        public bool IsInputFormat64 { get { return _isInputFormat64; } protected set { _isInputFormat64 = value; } }

        /// <summary>Whether input is in form of hexadecimal encoded byte array.</summary>
        public bool IsInputFormatHex { get { return _isInputFormatHex; } protected set { _isInputFormatHex = value; } }

        /// <summary>Whether output format is ordinary string. Returns true if there is no binary
        /// format specified, false if there is.</summary>
        bool IsOutputFormatString
        {
            get { return !(IsOutputFormatLongInt || IsOutputFormat64 || IsOutputFormatHex); }
            set
            {
                if (value == true)
                {
                    IsOutputFormatLongInt = false;
                    IsOutputFormat64 = false;
                    IsOutputFormatHex = false;
                }
                else
                {
                    if (!(IsInputFormatLongInt || IsInputFormat64 || IsInputFormatHex))
                        throw new ArgumentException("Input format must be strig where there is no binary format defined.");
                }
            }
        }

        bool _isOutputFormatLongInt = false;
        bool _isOutputFormat64 = false;
        bool _isOutputFormatHex = false;

        /// <summary>Whether output is in form of long integer.</summary>
        public bool IsOutputFormatLongInt { get { return _isOutputFormatLongInt; } protected set { _isOutputFormatLongInt = value; } }  // whether output format is long integer

        /// <summary>Whether output is in form of base-64 encoded byte array.</summary>
        public bool IsOutputFormat64 { get { return _isOutputFormat64; } protected set { _isOutputFormat64 = value; } }

        /// <summary>Whether output is in form of hexadecimal encoded byte array.</summary>
        public bool IsOutputFormatHex { get { return _isOutputFormatHex; } protected set { _isOutputFormatHex = value; } }




        #endregion Data




        /// <summary>Reads parameters for cryptographic operations to be performed from the specified command line.
        /// <para>Parameters read from this function can be used by any high level function that actually performs 
        /// cryptographic operations.</para></summary>
        /// <param name="appName">Name of the embedded application for which parameters are read.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual void ParseCommandlineParameters(string appName, string[] args)
        {
            // Store parameters:
            this.AppName = appName;
            this.AppArguments = args;

            for (int whichArg = 0; whichArg < NumAppArguments; ++whichArg)
            {
                string arg = args[whichArg];
                string argLowercase = arg.ToLower();
                if (OutputLevel >= 5)
                {
                    if (whichArg == 0)
                        Console.WriteLine("Argument No. " + whichArg + " (command name): " + arg);
                    else
                        Console.WriteLine("Argument No. " + whichArg + ": " + arg);
                }
                //if (whichArg == 0)
                //    ;  //  arg. No. 0 skipped because it represents command name.
                // Any argument:

                // ALGORITHM TYPE OPTIONS:
                if (argLowercase == CC.ArgAlgorithmType || argLowercase == CC.ArgAlgorithmType1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by password algorithm type string.");
                    else
                    {
                        ++whichArg;
                        if (AlgorithmTypeString != null)
                            ReportError("Algorithm type already specified, will be overwritten.");
                        AlgorithmTypeString = args[whichArg];

                        bool couldSetAlgorithm = false;
                        if (IsFlagsSet(CryptoFlags.Hashing))
                        {
                            try
                            {
                                HashType t = HashType.None;
                                t = UtilCrypto.GetHashType(AlgorithmTypeString);
                                HashAlgorithmType = t;
                                couldSetAlgorithm = true;
                            }
                            catch (Exception) { }
                        }
                        if (IsFlagsSet(CryptoFlags.SymmetricEncryption))
                        {
                            try
                            {
                                SymmetricAlgorithmType t = SymmetricAlgorithmType.None;
                                t = UtilCrypto.GetSymmetricAlgorithmType(AlgorithmTypeString);
                                SymmetricAlgorithmType = t;
                                couldSetAlgorithm = true;
                            }
                            catch (Exception) { }
                        }
                        if (IsFlagsSet(CryptoFlags.AsymmetricEncryption))
                        {
                            try
                            {
                                AsymmetricAlgorithmType t = AsymmetricAlgorithmType.None;
                                t = UtilCrypto.GetAsymmetricAlgorithmType(AlgorithmTypeString);
                                AsymAlgorithmType = t;
                                couldSetAlgorithm = true;
                            }
                            catch (Exception) { }
                        }
                        if (IsFlagsSet(CryptoFlags.KeyGeneration))
                        {
                            try
                            {
                                PasswordAlgorithmType t = PasswordAlgorithmType.None;
                                t = UtilCrypto.GetPasswordAlgorithmType(AlgorithmTypeString);
                                PasswordAlgorithmType = t;
                                couldSetAlgorithm = true;
                            }
                            catch (Exception) { }
                        }
                        if (!couldSetAlgorithm)
                        {
                            ReportError("The following algorithm type is unknown: " + AlgorithmTypeString);
                        }
                    }
                }
                else if (argLowercase == CC.ArgPasswordAlgorithmType || argLowercase == CC.ArgPasswordAlgorithmType1)
                {
                    // The same as CC.ArgAlgorithmType!
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by password algorithm type string.");
                    else
                    {
                        ++whichArg;
                        if (PasswordAlgorithmTypeString != null)
                            ReportError("Password algorithm type already specified, will be overwritten.");
                        PasswordAlgorithmTypeString = args[whichArg];
                        PasswordAlgorithmType = UtilCrypto.GetPasswordAlgorithmType(PasswordAlgorithmTypeString);
                        if (PasswordAlgorithmType == PasswordAlgorithmType.None)
                        {
                            ReportError("Unrecognized key generation algorithm type: " + PasswordAlgorithmTypeString + ".");
                        }
                    }
                }
                else if (argLowercase == CC.ArgLargestKey || argLowercase == CC.ArgLargestKey1)
                {
                    ++whichArg;
                    bool successful = Util.TryParse(args[whichArg], ref _isLargestKey);
                    if (!successful)
                        ReportError("Largest key flag is not specified in the correct format: " + args[whichArg]);
                }
                else if (argLowercase == CC.ArgDecrypt || argLowercase == CC.ArgDecrypt1)
                { IsDecrypt = true; }
                else if (argLowercase == CC.ArgEncrypt || argLowercase == CC.ArgEncrypt1)
                { IsEncrypt = true; }


                // HASH ALGORITHM OPTIONS:
                else if (argLowercase == CC.ArgHashValue || argLowercase == CC.ArgHashValue1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by hash value.");
                    else
                    {
                        ++whichArg;
                        HashValue = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgString || argLowercase == CC.ArgString1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a string.");
                    else
                    {
                        //++whichArg;
                        //workedString = AppArguments[whichArg];
                        IsStringInput = true;
                    }
                }


                // GENERAL OPTIONS:
                else if (argLowercase == CC.ArgCheck || argLowercase == CC.ArgCheck1)
                {
                    IsChecked = true;
                }
                // TIME TESTING - RELATED PARAMETERS:
                else if (argLowercase == CC.ArgTime || argLowercase == CC.ArgTime1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by targeted total execution time.");
                    else
                    {
                        ++whichArg;
                        double targTime = TargetedTotalTime;
                        bool successful = Util.TryParse(args[whichArg], ref targTime);
                        TargetedTotalTime = targTime;
                        if (!successful)
                            ReportError("Targeted total execution time is not in correct format: " + args[whichArg]);
                    }
                }

                // INOUT/OUTPUT FORMAT OPTIONS:
                else if (argLowercase == CC.ArgBinaryInputFormatHex || argLowercase == CC.ArgBinaryInputFormatHex1)
                {
                    IsInputFormatHex = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsOutputFormatHex = true;
                }
                else if (argLowercase == CC.ArgBinaryOutputFormatHex || argLowercase == CC.ArgBinaryOutputFormatHex1)
                {
                    IsOutputFormatHex = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsInputFormatHex = true;
                }

                else if (argLowercase == CC.ArgBinaryInputFormatBase64 || argLowercase == CC.ArgBinaryInputFormatBase641)
                {
                    IsInputFormat64 = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsOutputFormat64 = true;
                }
                else if (argLowercase == CC.ArgBinaryOutputFormatBase64 || argLowercase == CC.ArgBinaryOutputFormatBase64)
                {
                    IsOutputFormat64 = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsInputFormat64 = true;
                }

                else if (argLowercase == CC.ArgBinaryInputFormatLongInt || argLowercase == CC.ArgBinaryInputFormatLongInt1)
                {
                    IsInputFormatLongInt = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsOutputFormatLongInt = true;
                }
                else if (argLowercase == CC.ArgBinaryOutputFormatLongInt || argLowercase == CC.ArgBinaryOutputFormatLongInt1)
                {
                    IsOutputFormatLongInt = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsInputFormatLongInt = true;
                }

                else if (argLowercase == CC.ArgStringInputFormat || argLowercase == CC.ArgStringInputFormat1)
                {
                    IsInputFormatString = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsOutputFormatString = true;
                }
                else if (argLowercase == CC.ArgStringOutputFormat || argLowercase == CC.ArgStringOutputFormat1)
                {
                    IsOutputFormatString = true;
                    if (IsInputFormatEqualOutputFormat)
                        IsInputFormatString = true;
                }


              // FILE PATHS:
                else if (argLowercase == CC.ArgPathsAbsolute || argLowercase == CC.ArgPathsAbsolute1)
                {
                    IsAbsolutePaths = true;
                }
                else if (argLowercase == CC.ArgPathsRelative || argLowercase == CC.ArgPathsRelative1)
                {
                    IsRelativePaths = true;
                }
                else if (argLowercase == CC.ArgDeleteOriginal || argLowercase == CC.ArgDeleteOriginal1)
                {
                    IsDeleteOriginal = true;
                }
                else if (argLowercase == CC.ArgDeleteEncrypted || argLowercase == CC.ArgDeleteEncrypted1)
                {
                    IsDeleteEncrypted = true;
                }
                else if (argLowercase == CC.ArgDeleteDecrypted || argLowercase == CC.ArgDeleteDecrypted1)
                {
                    IsDeleteDecrypted = true;
                }
                else if (argLowercase == CC.ArgDeleteAllVersions || argLowercase == CC.ArgDeleteAllVersions1)
                {
                    IsDeleteAllVersions = true;
                }

                else if (argLowercase == CC.ArgForceOverwrite || argLowercase == CC.ArgForceOverwrite1)
                {
                    IsForceOverwrites = true;
                }
                else if (argLowercase == CC.ArgSkipOverwrite || argLowercase == CC.ArgSkipOverwrite1)
                {
                    IsSkipOverwrites = true;
                }
                else if (argLowercase == CC.ArgForceDelete || argLowercase == CC.ArgForceDelete1)
                {
                    IsForceDeletes = true;
                }
                else if (argLowercase == CC.ArgSkipDelete || argLowercase == CC.ArgSkipDelete1)
                {
                    IsSkipDeletes = true;
                }
                else if (argLowercase == CC.ArgOutputFile || argLowercase == CC.ArgOutputFile1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by output file path.");
                    else
                    {
                        ++whichArg;
                        OutputPath = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgRecursiveDirectory || argLowercase == CC.ArgRecursiveDirectory1)
                {
                    // New path for recursive directory listing of input files:
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a directory path for recursive file search.");
                    else
                    {
                        ++whichArg;
                        RecursivePathList.Add(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgRecursiveDirectoryByLevels || argLowercase == CC.ArgRecursiveDirectoryByLevels1)
                {
                    // New file search pattern for recursive directory listing of input files:
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a directory path for level-sorted recursive file search.");
                    else
                    {
                        ++whichArg;
                        RecursivePathListByLevels.Add(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgRecursiveDirectoryPattern || argLowercase == CC.ArgRecursiveDirectoryPattern1)
                {
                    // New file search pattern for recursive directory listing of input files:
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a file pattern for recursive file search.");
                    else
                    {
                        ++whichArg;
                        RecursiveFilePatterns.Add(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgRecursiveDirectoryLevel || argLowercase == CC.ArgRecursiveDirectoryLevel1)
                {
                    // New file search pattern for recursive directory listing of input files:
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a directory level for recursive file search.");
                    else
                    {
                        ++whichArg;
                        Util.TryParse(args[whichArg], ref RecursiveDirectoryLevels);
                    }
                }

                // ASYMMETRIC KEY RELATED ARGUMENTS
                else if (argLowercase == CC.ArgAsymAlgorithmType || argLowercase == CC.ArgAsymAlgorithmType1)
                {
                    // The same as CC.ArgAlgorithmType!
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by asymmetric algorithm type string.");
                    else
                    {
                        ++whichArg;
                        if (AsymAlgorithmTypeString != null)
                            ReportError("Asymmetric algorithm type already specified, will be overwritten.");
                        AsymAlgorithmTypeString = args[whichArg];
                        AsymAlgorithmType = UtilCrypto.GetAsymmetricAlgorithmType(PasswordAlgorithmTypeString);
                        if (AsymAlgorithmType == AsymmetricAlgorithmType.None)
                        {
                            ReportError("Unrecognized asymmetric algorithm type: " + AsymAlgorithmTypeString + ".");
                        }
                    }
                }
                else if (argLowercase == CC.ArgAsymKeyName || argLowercase == CC.ArgAsymKeyName)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by asymmetric key container name.");
                    else
                    {
                        ++whichArg;
                        AsymKeyContainerName = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgAsymKeyXmlFile || argLowercase == CC.ArgAsymKeyXmlFile1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by path to asymmetric key XML file.");
                    else
                    {
                        ++whichArg;
                        AsymKeyFileXml = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgCertificateFile || argLowercase == CC.ArgCertificateFile1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by path to certificate file.");
                    else
                    {
                        ++whichArg;
                        CertificatePath = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgAsymKeyFlag || argLowercase == CC.ArgAsymKeyFlag1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by a CSP flag name.");
                    else
                    {
                        ++whichArg;
                        CspProviderFlags flag = CspProviderFlags.NoFlags;
                        flag = UtilCrypto.GetCspProviderFlags(args[whichArg]);
                        if ((flag & AsymFlags) != 0)
                            ReportWarning("Asymmetric crypto provider flag already set: " + flag.ToString());
                        AsymFlags |= flag;
                    }
                }
                else if (argLowercase == CC.ArgAsymExportPrivateKey || argLowercase == CC.ArgAsymExportPrivateKey1)
                {
                    IsExportPrivateKey = true;
                    WarnExportPrivateKey();
                }
                else if (argLowercase == CC.ArgCertificatePasswordThroughUI || argLowercase == CC.ArgCertificatePasswordThroughUI1)
                {
                    IsCertificatePasswordThroughUi = true;
                }
                else if (argLowercase == CC.ArgCertificatePassword || argLowercase == CC.ArgCertificatePassword1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by the password for private key.");
                    else
                    {
                        ++whichArg;
                        CertificatePassword = args[whichArg];
                    }
                }

                // PASSWORD AND SALT RELATED OPTIONS
                else if (argLowercase == CC.ArgPasswordString || argLowercase == CC.ArgPasswordString1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by password string.");
                    else
                    {
                        ++whichArg;
                        PasswordString = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgPasswordHexBytes || argLowercase == CC.ArgPasswordHexBytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by password bytes in hexadecimal form.");
                    else
                    {
                        ++whichArg;
                        PasswordBytes = Util.FromHexString(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgPasswordBase64Bytes || argLowercase == CC.ArgPasswordBase64Bytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by base-64 encoded password bytes.");
                    else
                    {
                        ++whichArg;
                        PasswordBytes = Convert.FromBase64String(args[whichArg]);
                    }
                }


                else if (argLowercase == CC.ArgKeyHexBytes || argLowercase == CC.ArgKeyHexBytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by key bytes in hexadecimal form.");
                    else
                    {
                        ++whichArg;
                        KeyBytes = Util.FromHexString(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgKeyBase64Bytes || argLowercase == CC.ArgKeyBase64Bytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by base-64 encoded key bytes.");
                    else
                    {
                        ++whichArg;
                        KeyBytes = Convert.FromBase64String(args[whichArg]);
                    }
                }


                else if (argLowercase == CC.ArgSaltString || argLowercase == CC.ArgSaltString1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by salt string.");
                    else
                    {
                        ++whichArg;
                        SaltString = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgSaltHexBytes || argLowercase == CC.ArgSaltHexBytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by salt bytes in hexadecimall form.");
                    else
                    {
                        ++whichArg;
                        SaltBytes = Util.FromHexString(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgSaltBase64Bytes || argLowercase == CC.ArgSaltBase64Bytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by base-64 encoded salt bytes.");
                    else
                    {
                        ++whichArg;
                        SaltBytes = Convert.FromBase64String(args[whichArg]);
                    }
                }

                else if (argLowercase == CC.ArgIvString || argLowercase == CC.ArgIvString1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by initialization vector as string.");
                    else
                    {
                        ++whichArg;
                        IvString = args[whichArg];
                    }
                }
                else if (argLowercase == CC.ArgIvHexBytes || argLowercase == CC.ArgIvHexBytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by initialization vector bytes in hexadecimall form.");
                    else
                    {
                        ++whichArg;
                        IvBytes = Util.FromHexString(args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgIvBase64Bytes || argLowercase == CC.ArgIvBase64Bytes1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by base-64 encoded initialization vector bytes.");
                    else
                    {
                        ++whichArg;
                        IvBytes = Convert.FromBase64String(args[whichArg]);
                    }
                }

                else if (argLowercase == CC.ArgPasswordLength || argLowercase == CC.ArgPasswordLength1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by password length.");
                    else
                    {
                        ++whichArg;
                        bool successful = Util.TryParse(args[whichArg], ref PasswordLength);
                        if (!successful)
                            ReportError("Invalid format of password length: " + args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgKeyLength || argLowercase == CC.ArgKeyLength1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by key length.");
                    else
                    {
                        ++whichArg;
                        bool successful = Util.TryParse(args[whichArg], ref KeyLength);
                        if (!successful)
                            ReportError("Invalid format of key length: " + args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgSaltLength || argLowercase == CC.ArgSaltLength1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by salt length.");
                    else
                    {
                        ++whichArg;
                        bool successful = Util.TryParse(args[whichArg], ref SaltLength);
                        if (!successful)
                            ReportError("Invalid format of salt length: " + args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgIvLength || argLowercase == CC.ArgIvLength1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by initialization vector length.");
                    else
                    {
                        ++whichArg;
                        bool successful = Util.TryParse(args[whichArg], ref IvLength);
                        if (!successful)
                            ReportError("Invalid format of initializattion vector length: " + args[whichArg]);
                    }
                }
                else if (argLowercase == CC.ArgPasswordNumIterations || argLowercase == CC.ArgPasswordNumIterations1)
                {
                    if (whichArg + 1 >= NumAppArguments)
                        ReportError("Argument \"" + arg + "\" should be followed by number of iterations in key generation algorithm.");
                    else
                    {
                        ++whichArg;
                        bool successful = Util.TryParse(args[whichArg], ref NumPasswordIterations);
                        if (!successful)
                            ReportError("Argument can not be interpreted as integer number of key generation iterations: " + args[whichArg]);
                    }
                }
                else
                {
                    FreeParameters.Add(args[whichArg]);
                }
            }

        }  // ParseCommandlineParameters()


        /// <summary>Gets a list of input files specified by command-line arguments that had been previously parsed
        /// by the <see cref="ParseCommandlineParameters"/> method.</summary>
        /// <param name="inputFilePaths">List where the obtained input file paths are stored.</param>
        /// <param name="enableWildcards">If true (which is default) then file paths listed as free parameters will be resolved 
        /// by expanding wildcard characters.</param>
        /// <param name="addRecursive">If true (which is default) then files obtained by recursive directory listings are also included.</param>
        /// <param name="clearBefore">If true (which is default) then the list <paramref name="inputFilePaths"/> is cleared
        /// before operation. If false then extracted file paths are added to the eventual existing items already on the list.
        /// This is an untypical situation and there will rarely bee any need for this.</param>
        public virtual void GetInputFilePaths(ref List<string> inputFilePaths,
            bool enableWildcards = true, bool addRecursive = true, bool clearBefore = true)
        {
            if (inputFilePaths == null)
                inputFilePaths = new List<string>();
            else if (clearBefore)
                inputFilePaths.Clear();
            // Input file arguments:
            foreach (string arg in FreeParameters)
            {
                if (!string.IsNullOrEmpty(arg))
                {
                    if (File.Exists(arg))  // argument represtens a file
                        inputFilePaths.Add(arg);
                    else if (Directory.Exists(arg))
                    {
                        // argument represents a directory: 
                        string[] paths = Directory.GetFiles(arg);
                        foreach (string path in paths)
                        {
                            if (File.Exists(path))
                            {
                                inputFilePaths.Add(path);
                                // inputFilePaths.Add(UtilSystem.GetRelativePath(".", path));
                            }
                        }
                    }
                    else
                    {
                        string[] paths = Directory.GetFiles(".", arg);
                        if (paths == null || paths.Length == 0)
                        {
                            ReportError("No files or directories correespond to path specification: \"" + arg + "\"");
                        }
                        else
                        {
                            foreach (string path in paths)
                            {
                                if (File.Exists(path))
                                {
                                    inputFilePaths.Add(path);
                                }
                            }
                        }
                    }
                }
            }

            if (RecursivePathList.Count > 0)
            {
                int numAdded = UtilSystem.ListFilesRecursively(null, ref RecursivePathList, null /*auxlist */, RecursiveDirectoryLevels /* numLevels*/,
                    true /* includeList */, true /* clearOnbeginning */, false /* relativeaths */, false /* listDirectories */,
                    true /* listFiles */, RecursiveFilePatterns);
                if (RecursivePathList.Count > 0)
                {
                    foreach (string filePath in RecursivePathList)
                    {
                        inputFilePaths.Add(filePath);
                    }
                }
                else
                {
                    ReportError("No files found recursively.");
                }
            }
            if (RecursivePathListByLevels.Count > 0)
            {
                int numAdded = UtilSystem.ListFilesByLevels(null, ref RecursivePathListByLevels, null /*auxlist */, RecursiveDirectoryLevels /* numLevels*/,
                    true /* includeList */, true /* clearOnbeginning */, false /* relativeaths */, false /* listDirectories */,
                    true /* listFiles */, RecursiveFilePatterns);
                if (RecursivePathListByLevels.Count > 0)
                {
                    foreach (string filePath in RecursivePathListByLevels)
                    {
                        inputFilePaths.Add(filePath);
                    }
                }
                else
                {
                    ReportError("No files found recursively.");
                }
            }
            if (IsRelativePaths || IsAbsolutePaths)
            {
                // Transform the paths in order to satisfy additional requirements, e.g. to be relative or absolute paths:
                int numInputFiles = inputFilePaths.Count;
                for (int i = 0; i < numInputFiles; ++i)
                {
                    if (IsRelativePaths)
                        inputFilePaths[i] = UtilSystem.GetRelativePath(".", inputFilePaths[i]);
                    if (IsAbsolutePaths)
                        inputFilePaths[i] = UtilSystem.GetAbsolutePath(inputFilePaths[i]);

                }
            }
        }


        #region Actions




        /// <summary>Executes command-line action - symmetric encryption of files or text by using BASIC class of methods.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppEncryptSymmetricBasic(string appName, string[] args)
        {
            bool isDecrypt = false;
            bool isPlain = false;
            bool isBasic = true;
            return AppEncryptSymmetricAll(appName, args, isDecrypt, isPlain, isBasic);
        }

        /// <summary>Executes command-line action - symmetric decryption of files or text by using BASIC class of methods.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppDecryptSymmetricBasic(string appName, string[] args)
        {
            bool isDecrypt = true;
            bool isPlain = false;
            bool isBasic = true;
            return AppEncryptSymmetricAll(appName, args, isDecrypt, isPlain, isBasic);
        }

        /// <summary>Executes command-line action - symmetric encryption of files or text by using PLAIN class of methods.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppEncryptSymmetricPlain(string appName, string[] args)
        {
            bool isDecrypt = false;
            bool isPlain = true;
            bool isBasic = false;
            return AppEncryptSymmetricAll(appName, args, isDecrypt, isPlain, isBasic);
        }

        /// <summary>Executes command-line action - symmetric decryption of files or text by using PLAIN class of methods.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppDecryptSymmetricPlain(string appName, string[] args)
        {
            bool isDecrypt = true;
            bool isPlain = true;
            bool isBasic = false;
            return AppEncryptSymmetricAll(appName, args, isDecrypt, isPlain, isBasic);
        }



        /// <summary>Executes command-line action - symmetric encryption of files or text.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        /// <param name="isDecrypt">If true then decryption is performed, otherwise encryption is performed.</param>
        /// <param name="isPlain">If true then PLAIN class of encryption/decrypton methods is used.</param>
        /// <param name="isBasic">If true then BASIC class of encryption/decryption metthods is used.</param>
        protected virtual string AppEncryptSymmetricAll(string appName, string[] args, bool isDecrypt = false,
            bool isPlain = false, bool isBasic = false)
        {

            if (isPlain)
                WarnAboutPlainEncryption();

            int numClases = 0;
            if (isPlain)
                ++numClases;
            if (isBasic)
                ++numClases;
            if (numClases < 1)
            {
                ReportError("The class of higher-level symmetric encryption methods is not specified.");
                return null;
            }
            else if (numClases > 1)
            {
                ReportError("More than one class of higher-level symmetric encryption methods is specified.");
                return null;
            }

            ClearAllFlags();
            SetFlags(CryptoFlags.SymmetricEncryption);
            this.IsDecrypt = isDecrypt;
            IsInputFormatEqualOutputFormat = false;

            // Basic parameter extraction from command-line:
            ParseCommandlineParameters(appName, args);


            // Arrange the parameters parsed through command-line: 

            if (isPlain)
            {

                if (this.KeyBytes == null)
                {
                    if (!string.IsNullOrEmpty(this.PasswordString) || this.PasswordBytes != null)
                    {
                        if (this.PasswordBytes != null)
                        {
                            this.KeyBytes = this.PasswordBytes;
                            ReportWarning("Encryption key was copied from password bytes.");
                        }
                        else
                        {
                            this.KeyBytes = UtilCrypto.StringEncoding.GetBytes(this.PasswordString);
                            ReportWarning("Encryption key was copied from password string.");
                        }
                    }
                    if (this.KeyBytes == null)
                    {
                        Console.WriteLine(Environment.NewLine + "Secret password / key for symmetric encryption must be specified.");
                        string keyName = "key";
                        bool isStringForm = false;
                        bool isByteForm = false;
                        string keyString = null;
                        UtilConsole.ReadPwd(ref KeyBytes, ref keyString, keyName, isStringForm, isByteForm, false /* isHexForm */, false /* isBase64Encoded */,
                            true /* verify */);
                        if (KeyBytes == null && keyString != null)
                            KeyBytes = UtilCrypto.StringEncoding.GetBytes(keyString);
                    }
                }

                if (string.IsNullOrEmpty(IvString) && this.IvBytes == null)
                {
                    Console.WriteLine(Environment.NewLine + "Initializaton vector for symmetric encryption must be specified.");
                    string passwordName = "initialization vector (IV)";
                    bool isStringForm = false;
                    bool isByteForm = false;
                    UtilConsole.ReadPwd(ref IvBytes, ref IvString, passwordName, isStringForm, isByteForm, false /* isHexForm */, false /* isBase64Encoded */,
                        true /* verify */);
                }
                if (IvBytes == null && !string.IsNullOrEmpty(IvString))
                    IvBytes = UtilCrypto.StringEncoding.GetBytes(IvString);
                if (SaltBytes == null && !string.IsNullOrEmpty(SaltString))
                    SaltBytes = UtilCrypto.StringEncoding.GetBytes(SaltString);
                if (KeyBytes != null)
                    KeyLength = KeyBytes.Length;
                else
                    KeyLength = 0;
                if (IvBytes != null)
                    IvLength = IvBytes.Length;
                else
                    IvLength = 0;
                if (SaltBytes != null)
                    SaltLength = SaltBytes.Length;
                else if (IsEncrypt)
                    SaltLength = 0;
            }


            if (IsStringInput)
            {
                // Encryption of text (STRINGS or byte arrays) rather than files:
                if (IsChecked)
                {
                    // Check encryption of text (strings or byte arrays):

                    // TODO: implement this section!
                    // Currently, this block is still from the CheckSum command. Uncomment and implemennt properly:
                    throw new NotImplementedException("Checking encryption of text is not yet implemented. Coming soon (hopefully :-)) ).");

                    //// REFERENCE BODY FROM the CkeckSum command:
                    //// String hashRet verification:
                    //if (NumFreeParameters > 1)
                    //    ReportError("Redundant specification of hashed strings, only one will be used.");
                    //if (OutputPath != null)
                    //    ReportError("Redundant output file specification, not used.");
                    //if (NumFreeParameters < 1)
                    //    ReportError("The string to be checked is not specified.");
                    //else
                    //{
                    //    string workedString = FreeParameters[0];
                    //    bool checkPassed = false;
                    //    if (string.IsNullOrEmpty(HashValue))
                    //    {
                    //        ReportError("Hash value to be verified for a string is not specified.");
                    //    }
                    //    else
                    //    {
                    //        //checkPassed = UtilCrypto.CheckStringHashHex(workedString, HashValue, HashAlgorithmType);


                    //        if (IsInputFormatString)
                    //        {
                    //            checkPassed = UtilCrypto.CheckStringHashHex(workedString, HashValue, HashAlgorithmType);
                    //        }
                    //        else
                    //        {
                    //            byte[] bytes = null;
                    //            if (IsInputFormatLongInt)
                    //            {
                    //                long val = 0;
                    //                bool parsed = Util.TryParse(workedString, ref val);
                    //                if (!parsed)
                    //                    ReportError("Input string does not represent an integer: \"" + workedString + "\".");
                    //                else
                    //                {
                    //                    Util.ToByteArray(val, ref bytes);
                    //                    checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                    //                }
                    //            }
                    //            else if (IsInputFormatHex)
                    //            {
                    //                bytes = Util.FromHexString(workedString);
                    //                checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                    //            }
                    //            else if (IsInputFormat64)
                    //            {
                    //                bytes = Convert.FromBase64String(workedString);
                    //                checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                    //            }
                    //        }
                    //    }
                    //    ReturnedString = checkPassed.ToString();
                    //    if (checkPassed)
                    //    {
                    //        Console.WriteLine(HashAlgorithmType.ToString() + " hashRet: OK." + Environment.NewLine);
                    //    }
                    //    else
                    //    {
                    //        Console.WriteLine(HashAlgorithmType.ToString() + " hashRet: NOT PASSED!" + Environment.NewLine);
                    //    }
                    //}
                }  // Check encryption of text (strings or byte arrays):
                else
                {
                    // Encrypt or decrypt text (STRINGS or byte arrays)

                    if (OutputPath != null)
                    {
                        if (NumFreeParameters > 1)
                            ReportWarning("Omly the last encrypted/decrypted text will be written to an output file.");
                    }

                    if (NumFreeParameters < 1)
                    {
                        if (IsEncrypt)
                            ReportError("No text to be encrypted. No free parameters.");
                        else
                            ReportError("No text to be decrypted. No free parameters.");
                    }
                    else
                    {
                        if (IsEncrypt)
                            Console.WriteLine(Environment.NewLine + "Symmetric encryption of strings ...");
                        else
                            Console.WriteLine(Environment.NewLine + "Symmetric DECRYPTION of strings ...");
                        Console.WriteLine("  Algorithm used: " + UtilCrypto.SymmetricAlgorithmTypeToString(SymmetricAlgorithmType));
                        Console.WriteLine("  Original key length: " + KeyLength);
                        Console.WriteLine("  Original IV length: " + IvLength);
                        Console.WriteLine("  Salt length: " + SaltLength);
                        Console.Write("  Input format: ");
                        if (IsInputFormatString)
                            Console.WriteLine("string.");
                        else
                        {
                            Console.Write("binary ");
                            if (IsInputFormatHex)
                                Console.Write("(hexadecimal)");
                            else if (IsInputFormat64)
                                Console.Write("(base 64)");
                            else
                                Console.Write("(unspecified)");
                            Console.WriteLine(".");
                        }
                        Console.Write("  Output format: ");
                        if (IsOutputFormatString)
                            Console.WriteLine("string.");
                        else
                        {
                            Console.Write("binary ");
                            if (IsOutputFormatHex)
                                Console.Write("(hexadecimal)");
                            else if (IsOutputFormat64)
                                Console.Write("(base 64)");
                            else
                                Console.Write("(unspecified)");
                            Console.WriteLine(".");
                        }
                        StopWatch1 sw = new StopWatch1();
                        for (int i = 0; i < NumFreeParameters; ++i)
                        {
                            string str = FreeParameters[i];
                            ReturnedString = null;
                            if (IsInputFormatString)
                            {
                                if (IsEncrypt)
                                {
                                    sw.Start();
                                    if (isBasic)
                                    {
                                        throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                    }
                                    else if (isPlain)
                                    {
                                        ReturnedString = UtilCrypto.EncryptStringPlain(str, KeyBytes, IvBytes, SymmetricAlgorithmType,
                                            null /* algorithm */, SaltBytes, this.IsLargestKey);
                                    }
                                    sw.Stop();
                                    Console.WriteLine(Environment.NewLine + "Original string: " + Environment.NewLine + "  \"" +
                                        str + "\"" + Environment.NewLine + "Encrypted string: " + Environment.NewLine + "  " +
                                        ReturnedString + "" + Environment.NewLine + Environment.NewLine
                                        + "Time spent: " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                }
                                else
                                {
                                    sw.Start();
                                    if (isBasic)
                                    {
                                        throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                    }
                                    else if (isPlain)
                                    {
                                        ReturnedString = UtilCrypto.DecryptStringPlain(str, KeyBytes, IvBytes, SymmetricAlgorithmType,
                                            null /* algorithm */, SaltLength, this.IsLargestKey);
                                    }
                                    sw.Stop();
                                    Console.WriteLine(Environment.NewLine + "Encrypted string: " + Environment.NewLine + "  \"" +
                                        str + "\"" + Environment.NewLine + "Restored original string (decrypted): " + Environment.NewLine + "  \"" +
                                        ReturnedString + "\"" + Environment.NewLine + Environment.NewLine
                                        + "Time spent: " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                }
                            }
                            else
                            {
                                byte[] inputBytes = null;
                                byte[] outputBytes = null;
                                // Binary encryption / decryption
                                if (IsInputFormatHex)
                                {
                                    inputBytes = Util.FromHexString(str);
                                }
                                else if (IsInputFormat64)
                                {
                                    inputBytes = Convert.FromBase64String(str);
                                }

                                if (IsEncrypt)
                                {
                                    sw.Start();
                                    if (isBasic)
                                    {
                                        throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                    }
                                    else if (isPlain)
                                    {

                                        outputBytes = UtilCrypto.EncryptPlain(inputBytes, KeyBytes, IvBytes, SymmetricAlgorithmType,
                                            null /* algorithm */, SaltBytes, this.IsLargestKey);
                                    }
                                    sw.Stop();
                                    Console.WriteLine(Environment.NewLine + "Original bytes: " + Environment.NewLine + "  " +
                                        str + " " + Environment.NewLine
                                        + "Encrypted bytes (hexadecimal form): " + Environment.NewLine
                                        + "  " + Util.ToHexString(outputBytes) + "" + Environment.NewLine
                                        + "Encrypted bytes (base-64 encoding): " + Environment.NewLine
                                        + "  " + Convert.ToBase64String(outputBytes) + "" + Environment.NewLine + Environment.NewLine
                                        + "Time spent: " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                }
                                else
                                {
                                    sw.Start();
                                    if (isBasic)
                                    {
                                        throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                    }
                                    else if (isPlain)
                                    {
                                        outputBytes = UtilCrypto.DecryptPlain(inputBytes, KeyBytes, IvBytes, SymmetricAlgorithmType,
                                            null /* algorithm */, SaltLength, this.IsLargestKey);
                                    }
                                    sw.Stop();
                                    Console.WriteLine(Environment.NewLine + "Encrypted bytes: " + Environment.NewLine + "  " +
                                        str + " " + Environment.NewLine
                                        + "Restored original bytes (hexadecimal form): " + Environment.NewLine
                                        + "  " + Util.ToHexString(outputBytes) + "" + Environment.NewLine
                                        + "Restored original bytes (base-64 encoding): " + Environment.NewLine
                                        + "  " + Convert.ToBase64String(outputBytes) + "" + Environment.NewLine
                                        + "Restored original bytes converted to a string: " + Environment.NewLine
                                        + "  " + UtilCrypto.StringEncoding.GetString(outputBytes) + "" + Environment.NewLine + Environment.NewLine
                                        + "Time spent: " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                }
                                if (IsOutputFormatHex)
                                {
                                    ReturnedString = Util.ToHexString(outputBytes);
                                }
                                else if (IsOutputFormat64)
                                {
                                    ReturnedString = Convert.ToBase64String(outputBytes);
                                }
                                else
                                {
                                    ReturnedString = Convert.ToBase64String(outputBytes);
                                }
                            }
                        }
                        Console.WriteLine("Total time spend: " + sw.TotalTime + " s (CPU: " + sw.TotalCpuTime + ")." + Environment.NewLine);
                        if (ReturnedString != null && !string.IsNullOrEmpty(OutputPath))
                        {
                            File.WriteAllText(OutputPath, ReturnedString);
                        }
                    }
                } // encrypt or decrypt text (STRINGS or byte arrays)
            } // Encryption of specified text (strings or byte arrays) rather than files
            else
            {
                // File encryption:
                if (IsChecked)
                {
                    // Check file encryption:

                    // TODO: implement this section!
                    // Currently, this block is still from the CheckSum command. Uncomment and implemennt properly:
                    throw new NotImplementedException("Encryption checks for files are not yet implemented. Coming soon (hopefully :-)) ).");

                    //// REFERENCE BODY FROM the CkeckSum command:
                    //// File hashRet verification:
                    //List<string> inputFilePaths = null;
                    //GetInputFilePaths(ref inputFilePaths, true  /* enableWildcards */, true /* addRecursive */, true /* clearBefore */);
                    //int numInputFiles = inputFilePaths.Count;
                    //ReturnedString = null;
                    //if (OutputPath != null)
                    //    ReportError("Redundant output file specification, not used.");
                    //bool checkPassed = false;
                    //if (HashValue != null)
                    //{
                    //    // Verify a single file whose hashRet is specified by command line:
                    //    if (numInputFiles < 1)
                    //    {
                    //        ReportError("No files for verification specified, there should be one file.");
                    //        checkPassed = false;
                    //        ReturnedString = checkPassed.ToString();
                    //    }
                    //    else
                    //    {
                    //        if (numInputFiles > 1)
                    //            ReportError("More than one file specified for verification, should be one. All will be ckecked.");
                    //        bool passedThis = true;
                    //        foreach (string inputFilePath in inputFilePaths)
                    //        {
                    //            try
                    //            {
                    //                if (!File.Exists(inputFilePath))
                    //                {
                    //                    passedThis = false;
                    //                    ReportError("File does not exist: " + inputFilePath);
                    //                }
                    //                else
                    //                    if (UtilCrypto.CheckFileHashHex(inputFilePath, HashValue, HashAlgorithmType))
                    //                    {
                    //                        Console.WriteLine("File " + HashAlgorithmType.ToString() + ": OK.");
                    //                    }
                    //                    else
                    //                    {
                    //                        passedThis = false;
                    //                        Console.WriteLine("File " + HashAlgorithmType.ToString() + ": NOT PASSED.");
                    //                    }
                    //            }
                    //            catch (Exception ex)
                    //            {
                    //                passedThis = false;
                    //                ReportError("Exception thrown: " + ex.Message);
                    //            }
                    //        }
                    //        checkPassed = passedThis;
                    //        ReturnedString = checkPassed.ToString();
                    //    }
                    //}
                    //else
                    //{
                    //    // Verification of mutiple file hashes from a file:
                    //    bool passedThis = true;
                    //    if (OutputPath != null)
                    //        ReportError("Redundant output file specification, not used.");
                    //    if (numInputFiles < 1)
                    //    {
                    //        ReportError("No files containing hashRet information are specified.");
                    //        passedThis = false;
                    //    }
                    //    else
                    //    {
                    //        int numCheckedAll = 0;
                    //        int numPassed = 0;
                    //        int numNotPassed = 0;
                    //        for (int whichInputFile = 0; whichInputFile < numInputFiles; ++whichInputFile)
                    //        {
                    //            string inputFilePath = inputFilePaths[whichInputFile];
                    //            // Read hashRet value / file pairs:
                    //            List<string[]> hashList = null;
                    //            UtilCrypto.ParseHashFile(inputFilePath, ref hashList);
                    //            Console.WriteLine(Environment.NewLine + "From input file " + Path.GetFileName(inputFilePath) + ":");
                    //            int numChecked = 0;
                    //            if (hashList != null)
                    //                numChecked = hashList.Count;
                    //            //if (numChecked == 0)
                    //            //{
                    //            //    Console.WriteLine("  No entries.");
                    //            //} else
                    //            {
                    //                foreach (string[] pair in hashList)
                    //                {
                    //                    string hashRet = pair[0];
                    //                    string checkedFile = pair[1];
                    //                    if (string.IsNullOrEmpty(hashRet) || string.IsNullOrEmpty(checkedFile))
                    //                    {
                    //                        if (string.IsNullOrEmpty(hashRet))
                    //                            ReportError("Hash not specified.");
                    //                        if (string.IsNullOrEmpty(checkedFile))
                    //                            ReportError("FilePath not specified.");
                    //                    }
                    //                    else
                    //                    {
                    //                        ++numCheckedAll;
                    //                        if (!File.Exists(checkedFile))
                    //                        {
                    //                            passedThis = false;
                    //                            ReportError("File does not exist: " + checkedFile);
                    //                            ++numNotPassed;
                    //                        }
                    //                        else
                    //                            if (UtilCrypto.CheckFileHashHex(checkedFile, hashRet, HashAlgorithmType))
                    //                            {
                    //                                Console.WriteLine(HashAlgorithmType.ToString() + " OK: " + checkedFile);
                    //                                ++numPassed;
                    //                            }
                    //                            else
                    //                            {
                    //                                passedThis = false;
                    //                                Console.WriteLine(HashAlgorithmType.ToString() + " NOT PASSED: " + checkedFile);
                    //                                ++numNotPassed;
                    //                            }
                    //                    }
                    //                }
                    //            }
                    //        }
                    //        if (numCheckedAll < 1)
                    //        {
                    //            passedThis = false;
                    //            Console.WriteLine("No files to check.");
                    //        }
                    //        else
                    //        {
                    //            if (numPassed < 1)
                    //                Console.WriteLine("No files passed.");
                    //            else if (numNotPassed < 1)
                    //                Console.WriteLine("All files OK.");
                    //            else
                    //            {
                    //                Console.WriteLine(numPassed.ToString() + " files passed, " + numNotPassed.ToString() + " NOT PASSED.");
                    //            }
                    //        }
                    //    }
                    //    checkPassed = passedThis;
                    //    ReturnedString = checkPassed.ToString();
                    //}
                    //ReturnedString = checkPassed.ToString();
                }  // check file encryption
                else
                {
                    // Encrypt files (not check)

                    // Encryption of one or more files:
                    List<string> inputFilePaths = null;
                    GetInputFilePaths(ref inputFilePaths, true  /* enableWildcards */, true /* addRecursive */, true /* clearBefore */);
                    int numInputFiles = inputFilePaths.Count;
                    ReturnedString = null;

                    if (numInputFiles < 1)
                    {
                        if (IsEncrypt)
                            ReportError("No files to be encrypted are specified. Nothing to be done.");
                        else
                            ReportError("No files to be decrypted are specified. Nothing to be done.");
                    }
                    else if (numInputFiles > 1 && OutputPath != null)
                    {
                        ReportError("Output file is specified while there are more than one input files." + Environment.NewLine
                            + "  Output file will not be used, output files are created by adding extensions to original names.");
                    }
                    else
                    {
                        bool isOutputFileExplicitlySpecified = false;
                        if (inputFilePaths.Count == 1 && !string.IsNullOrEmpty(OutputPath))
                        {
                            isOutputFileExplicitlySpecified = true;
                        }
                        if (IsEncrypt)
                            Console.WriteLine(Environment.NewLine + "Symmetric encryption of " + numInputFiles + " files ...");
                        else
                            Console.WriteLine(Environment.NewLine + "Symmetric DECRYPTION of " + numInputFiles + " files ...");
                        if (isOutputFileExplicitlySpecified)
                            Console.WriteLine("  Output file: " + OutputPath);
                        else
                            Console.WriteLine("  Output file not explicitly specified.");
                        Console.WriteLine("  Algorithm used: " + UtilCrypto.SymmetricAlgorithmTypeToString(SymmetricAlgorithmType));
                        Console.WriteLine("  Original key length: " + KeyLength);
                        Console.WriteLine("  Original IV length: " + IvLength);
                        Console.WriteLine("  Salt length: " + SaltLength);

                        bool answerOverwrite = false;
                        int numAnswersOverwrite = 0;
                        bool rememberAnswerOverwrite = false;
                        bool answerDelete = false;
                        int numAnswersDelete = 0;
                        bool rememberAnswerDelete = false;
                        int numCurrentInputFiles = inputFilePaths.Count;
                        for (int whichFile = 0; whichFile < numCurrentInputFiles; ++whichFile)
                        {
                            // Iterate over input files:
                            string inputFilePath = inputFilePaths[whichFile];
                            bool fileEligible = true;
                            string outputFilePath = null;

                            if (!File.Exists(inputFilePath))
                            {
                                fileEligible = false;
                                ReportError("File does not exist: " + inputFilePath);
                            }
                            else
                            {
                                if (!isOutputFileExplicitlySpecified)
                                {
                                    // Output file is not explicitly specified, take care to skip the appropriate files:
                                    // skip encrypted and decrypted files with distinctive extensions when encrypting,
                                    // and skip all files that do not have a distinctive extension for encrypted files 
                                    // when decrypting:
                                    string extension = Path.GetExtension(inputFilePath);
                                    if (IsEncrypt)
                                    {
                                        // Encryption takes place, skip files with either encryption or decryption
                                        // extension:
                                        if (extension == CC.FileExtensionEncrypted || extension == CC.FileExtensionDecrypted)
                                            fileEligible = false;
                                    }
                                    else
                                    {
                                        if (extension != CC.FileExtensionEncrypted)
                                            fileEligible = false;
                                    }
                                }
                            }
                            if (!fileEligible)
                            {
                                if (File.Exists(inputFilePath))
                                    ReportWarning("Skipped (not eligible): " + inputFilePath);
                            }
                            else
                            {
                                // Input file is eligible for encryption/decryption, determine the output file:
                                if (isOutputFileExplicitlySpecified)
                                {
                                    // Output file has been explicitly specified through an output option:
                                    outputFilePath = OutputPath;
                                }
                                else
                                {
                                    // Output file is not explicitly specified. Infer its name and path by adding / changing 
                                    // the appropriate extension to the input file, according to the action taken:
                                    if (IsEncrypt)
                                        outputFilePath = inputFilePath + CC.FileExtensionEncrypted;
                                    else
                                    {
                                        string extension = Path.GetExtension(inputFilePath);
                                        if (extension == CC.FileExtensionEncrypted)
                                        {
                                            if (this.IsDeleteOriginal)
                                            {
                                                outputFilePath = Path.Combine(
                                                Path.GetDirectoryName(inputFilePath),
                                                Path.GetFileNameWithoutExtension(inputFilePath));
                                            }
                                            else
                                            {
                                                outputFilePath = Path.Combine(
                                                    Path.GetDirectoryName(inputFilePath),
                                                    Path.GetFileNameWithoutExtension(inputFilePath) + CC.FileExtensionDecrypted);
                                            }
                                        }
                                        else
                                        {
                                            outputFilePath = inputFilePath + CC.FileExtensionDecrypted;
                                            if (this.IsDeleteOriginal)
                                            {
                                                ReportWarning("File path of the original (unencrypted) file could not be restored.");
                                            }
                                        }
                                    }  // decryption
                                }

                                if (string.IsNullOrEmpty(outputFilePath))
                                {
                                    ReportError("Could not specify output file path.");
                                }
                                else
                                {
                                    // About to encrypt/decrypt to the output file; Check whether the file exists 
                                    // and whether we need to overwrite or skip it:
                                    bool doWrite = false;
                                    if (!File.Exists(outputFilePath))
                                    {
                                        doWrite = true;
                                    }
                                    else
                                    {
                                        // Ouptut file already exist, decide whether to overwrite it:
                                        if (IsSkipOverwrites)
                                        {
                                            doWrite = false;
                                        }
                                        else if (IsForceOverwrites)
                                        {
                                            doWrite = true;
                                        }
                                        else
                                        {
                                            if (rememberAnswerOverwrite)
                                            {
                                                doWrite = answerOverwrite;
                                            }
                                            else
                                            {
                                                // Ask whether to overwrite a file:
                                                Console.Write(Environment.NewLine
                                                    + "Warning: Output file already exists: " + Environment.NewLine + "  " + outputFilePath
                                                    + Environment.NewLine + Environment.NewLine
                                                    + "Do you want to overwrite the file (0/1)? ");
                                                UtilConsole.Read(ref answerOverwrite);
                                                doWrite = answerOverwrite;

                                                //TODO: comment 4 lines below!
                                                if (doWrite)
                                                    Console.WriteLine(Environment.NewLine + "File will be overwritten." + Environment.NewLine);
                                                else
                                                    Console.WriteLine(Environment.NewLine + "File will be skipped." + Environment.NewLine);

                                                ++numAnswersOverwrite;
                                                if (numAnswersOverwrite == 1 && numCurrentInputFiles > whichFile + 1)
                                                {
                                                    Console.Write(Environment.NewLine + "Use this decision for all files (0/1)? ");
                                                    UtilConsole.Read(ref rememberAnswerOverwrite);
                                                    if (rememberAnswerOverwrite)
                                                    {
                                                        Console.WriteLine();
                                                        if (answerOverwrite)
                                                            Console.WriteLine("Further existing files will be automatically overwritten.");
                                                        else
                                                            Console.WriteLine("Further existing files will be automatically skipped.");
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (!doWrite)
                                    {
                                        ReportWarning("Skipped: " + inputFilePath);
                                    }
                                    else
                                    {

                                        bool operationLaunched = false;
                                        bool operationCompleted = false;
                                        bool outputFileExists = false;
                                        if (File.Exists(outputFilePath))
                                            outputFileExists = true;
                                        StopWatch1 sw = new StopWatch1();
                                        if (IsEncrypt)
                                        {
                                            // Perform encryption:
                                            Console.WriteLine(Environment.NewLine + "Encrypting file: " + Environment.NewLine +
                                                "  " + inputFilePath + Environment.NewLine +
                                                "to " + Environment.NewLine +
                                                "  " + outputFilePath + " ...");
                                            sw.Start();
                                            if (isBasic)
                                            {
                                                throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                                // operationLaunched = true;
                                                //
                                                // operationCompleted = true;
                                            }
                                            else if (isPlain)
                                            {
                                                operationLaunched = true;
                                                UtilCrypto.EncryptFilePlain(inputFilePath, outputFilePath, KeyBytes, IvBytes,
                                                    SymmetricAlgorithmType, null /* algorithm */, SaltBytes, CC.FileBufferSize,
                                                    this.IsLargestKey);
                                                operationCompleted = true;
                                            }
                                            sw.Stop();
                                            Console.WriteLine(Environment.NewLine +
                                                "... done in " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                        }
                                        else
                                        {
                                            // Perform decryption:
                                            Console.WriteLine(Environment.NewLine + "Decrypting file: " + Environment.NewLine +
                                                "  " + inputFilePath + Environment.NewLine +
                                                "to " + Environment.NewLine +
                                                "  " + outputFilePath + " ...");
                                            sw.Start();
                                            if (isBasic)
                                            {
                                                throw new NotImplementedException("Basic class of encryption/decryption functions not yet available. Coming soon.");
                                                // operationLaunched = true;
                                                // 
                                                // operationCompleted = true;
                                            }
                                            else if (isPlain)
                                            {
                                                operationLaunched = true;
                                                UtilCrypto.DecryptFilePlain(inputFilePath, outputFilePath, KeyBytes, IvBytes,
                                                SymmetricAlgorithmType, null /* algorithm */, SaltLength, CC.FileBufferSize,
                                                this.IsLargestKey);
                                                operationCompleted = true;
                                            }
                                            sw.Stop();
                                            Console.WriteLine(Environment.NewLine +
                                                "... done in " + sw.Time + " s (CPU: " + sw.CpuTime + ")." + Environment.NewLine);
                                        }
                                        if (operationLaunched && outputFileExists)
                                        {
                                            ReportInfo("Overwritten: " + outputFilePath);
                                        }
                                        if (IsDeleteOriginal && operationCompleted && !string.IsNullOrEmpty(inputFilePath))
                                        {
                                            bool doDelete = false;
                                            // Decide whether to delete the original (input) file:
                                            if (IsSkipDeletes)
                                            {
                                                doDelete = false;
                                            }
                                            else if (IsForceDeletes)
                                            {
                                                doDelete = true;
                                            }
                                            else
                                            {
                                                if (rememberAnswerDelete)
                                                {
                                                    doDelete = answerDelete;
                                                }
                                                else
                                                {
                                                    // Ask whether to delete a file:
                                                    Console.Write(Environment.NewLine
                                                        + "Warning: Input file will be deleted: " + Environment.NewLine + "  " + outputFilePath
                                                        + Environment.NewLine + Environment.NewLine
                                                        + "Do you really want to delete the file (0/1)? ");
                                                    UtilConsole.Read(ref answerDelete);
                                                    doDelete = answerDelete;

                                                    //if (doDelete)
                                                    //    Console.WriteLine(Environment.NewLine + "Input file will be deleted." + Environment.NewLine);
                                                    //else
                                                    //    Console.WriteLine(Environment.NewLine + "Input file deletion will be skipped." + Environment.NewLine);

                                                    ++numAnswersDelete;
                                                    if (numAnswersDelete == 1 && numCurrentInputFiles > whichFile + 1)
                                                    {
                                                        Console.Write(Environment.NewLine + "Use this decision for deletion of all input files after operation (0/1)? ");
                                                        UtilConsole.Read(ref rememberAnswerDelete);
                                                        if (rememberAnswerDelete)
                                                        {
                                                            Console.WriteLine();
                                                            if (answerDelete)
                                                                Console.WriteLine("Further input files will be automatically deleted after operation.");
                                                            else
                                                                Console.WriteLine("Deletion of further input files will be automatically skipped.");
                                                        }
                                                    }
                                                }
                                            }

                                            if (doDelete)
                                            {
                                                try
                                                {
                                                    File.Delete(inputFilePath);
                                                    ReportInfo("Deleted: " + inputFilePath);
                                                }
                                                catch (Exception ex)
                                                {
                                                    ReportError("File could not be deleted: " + inputFilePath + Environment.NewLine
                                                        + "  Error message: " + ex.Message);
                                                }
                                            }

                                        }  // deletion of input file
                                    }  // performing encryption/decryption
                                }
                            }  // eligible input file found, proceed
                        }  // loop over input files
                    }
                }  // encrypt files
            }  // file encryption 

            return ReturnedString;
        }  // AppEncryptSymmetricAll





        /// <summary>Executes command-line action - calculation of various hashRet values of a file.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppGetFileHash(string appName, string[] args)
        {
            ClearAllFlags();
            SetFlags(CryptoFlags.Hashing);
            ParseCommandlineParameters(appName, args);

            if (NumFreeParameters < 1)
                throw new ArgumentException("Path to the file whose hash values are calculated is not specified.");
            string filePath = null;
            bool writeToFile = false;
            string hashFileName = null;  // this will be determined from the file name unless specified by the 3rd argument
            if (NumFreeParameters >= 1)
            {
                filePath = FreeParameters[0];
                if (NumFreeParameters >= 2)
                {

                    if (!string.IsNullOrEmpty(filePath))
                        writeToFile = UtilStr.ToBoolean(FreeParameters[1]);
                    if (NumFreeParameters >= 3)
                    {
                        if (!string.IsNullOrEmpty(FreeParameters[2]))
                            hashFileName = FreeParameters[2];
                    }
                }
            }
            if (!File.Exists(filePath))
            {
                ReportError(Environment.NewLine
                    + "File whose hash values should be calculated does not exist!" + Environment.NewLine
                    + "  Path: " + filePath);
            }
            else
            {
                FileInfo info = new FileInfo(filePath);
                long fileLength = new FileInfo(filePath).Length;
                string directoryPath = Path.GetDirectoryName(filePath);
                string fileName = Path.GetFileName(filePath);
                Console.WriteLine(Environment.NewLine
                    + "Calculationg hash values for the file " + fileName + "..." + Environment.NewLine
                    + "  File length: " + fileLength + Environment.NewLine
                    + "  Complete path: " + filePath);
                Console.WriteLine("Calculating MD5 hash... ");
                string hashMD5 = UtilCrypto.GetFileHashMd5Hex(filePath);
                Console.WriteLine("  = " + hashMD5 + Environment.NewLine);
                Console.WriteLine("Calculating SHA1 hash... ");
                string hashSHA1 = UtilCrypto.GetFileHashSha1Hex(filePath);
                Console.WriteLine("  = " + hashSHA1 + Environment.NewLine);
                Console.WriteLine("Calculating SHA256 hash... ");
                string hashSHA256 = UtilCrypto.GetFileHashSha256Hex(filePath);
                Console.WriteLine("  = " + hashSHA256 + Environment.NewLine);
                Console.WriteLine("Calculating SHA512 hash... ");
                string hashSHA512 = UtilCrypto.GetFileHashSha512Hex(filePath);
                Console.WriteLine("  = " + hashSHA512 + Environment.NewLine);
                //Console.WriteLine(Environment.NewLine
                //  + "Hash values: " + Environment.NewLine
                //  + "  MD5:    " + hashMD5 + Environment.NewLine
                //  + "  SHA1:   " + hashSHA1 + Environment.NewLine
                //  + "  SHA256: " + hashSHA256 + Environment.NewLine
                //  + "  SHA512: " + hashSHA512 + Environment.NewLine);
                string hashFilePath = null;
                if (writeToFile)
                {
                    if (hashFileName == null)
                    {
                        hashFilePath = Path.Combine(directoryPath, fileName + CC.HashFileExtension);
                    }
                    else
                    {
                        hashFilePath = Path.Combine(directoryPath, hashFileName);
                    }
                    if (File.Exists(hashFilePath))
                    {
                        writeToFile = false;
                        Console.Write(Environment.NewLine + "Warning: File to which hash values should be saved already exists." + Environment.NewLine
                          + "  Path: " + hashFilePath + Environment.NewLine + Environment.NewLine
                          + "Do you want to overwrite the file (0/1)? ");
                        UtilConsole.Read(ref writeToFile);
                    }
                    if (writeToFile)
                    {
                        using (TextWriter writer = new StreamWriter(hashFilePath))
                        {
                            Console.WriteLine(Environment.NewLine + "Writing hash values to a file..." + Environment.NewLine
                                + "  path: " + hashFilePath);
                            writer.WriteLine(Environment.NewLine
                                + "File:   " + fileName + Environment.NewLine
                                + "Length: " + fileLength + Environment.NewLine + Environment.NewLine
                                + "Hash values: " + Environment.NewLine
                                + "  MD5:    " + Environment.NewLine + hashMD5 + Environment.NewLine
                                + "  SHA1:   " + Environment.NewLine + hashSHA1 + Environment.NewLine
                                + "  SHA256: " + Environment.NewLine + hashSHA256 + Environment.NewLine
                                + "  SHA512: " + Environment.NewLine + hashSHA512 + Environment.NewLine + "  " + Environment.NewLine);
                            Console.WriteLine("... writing done." + Environment.NewLine);
                        }
                    }
                }
            }
            return null;
        }

        /// <summary>Executes command-line action - calculation of various hashRet values of files or text.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppCheckSum(string appName, string[] args)
        {

            ClearAllFlags();
            SetFlags(CryptoFlags.Hashing);
            IsInputFormatEqualOutputFormat = true;
            ParseCommandlineParameters(appName, args);


            if (IsStringInput)
            {
                // Hash values for STRINGS:
                //if (numInputFiles > 0)
                //    ReportError("Hash files specified while checksum is calculated for a string.");
                if (IsChecked)
                {
                    // String hashRet verification:
                    if (NumFreeParameters > 1)
                        ReportError("Redundant specification of hashed strings, only one will be used.");
                    if (OutputPath != null)
                        ReportError("Redundant output file specification, not used.");
                    if (NumFreeParameters < 1)
                        ReportError("The string to be checked is not specified.");
                    else
                    {
                        string workedString = FreeParameters[0];
                        bool checkPassed = false;
                        if (string.IsNullOrEmpty(HashValue))
                        {
                            ReportError("Hash value to be verified for a string is not specified.");
                        }
                        else
                        {
                            //checkPassed = UtilCrypto.CheckStringHashHex(workedString, HashValue, HashAlgorithmType);


                            if (IsInputFormatString)
                            {
                                checkPassed = UtilCrypto.CheckStringHashHex(workedString, HashValue, HashAlgorithmType);
                            }
                            else
                            {
                                byte[] bytes = null;
                                if (IsInputFormatLongInt)
                                {
                                    long val = 0;
                                    bool parsed = Util.TryParse(workedString, ref val);
                                    if (!parsed)
                                        ReportError("Input string does not represent an integer: \"" + workedString + "\".");
                                    else
                                    {
                                        Util.ToByteArray(val, ref bytes);
                                        checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                                    }
                                }
                                else if (IsInputFormatHex)
                                {
                                    bytes = Util.FromHexString(workedString);
                                    checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                                }
                                else if (IsInputFormat64)
                                {
                                    bytes = Convert.FromBase64String(workedString);
                                    checkPassed = UtilCrypto.CheckHashHex(bytes, HashValue, HashAlgorithmType);
                                }
                            }
                        }
                        ReturnedString = checkPassed.ToString();
                        if (checkPassed)
                        {
                            Console.WriteLine(HashAlgorithmType.ToString() + " hash: OK." + Environment.NewLine);
                        }
                        else
                        {
                            Console.WriteLine(HashAlgorithmType.ToString() + " hash: NOT PASSED!" + Environment.NewLine);
                        }
                    }
                }
                else
                {
                    // String hashRet calculation:
                    if (HashValue != null)
                        ReportError("Redundant hash value, not used.");
                    if (OutputPath != null)
                        ReportError("Writing string hash value to a file is not supported, output file not used.");

                    //if (workedString != null)
                    //{
                    //    FreeParameters.Add(workedString);
                    //    //ReturnedString = UtilCrypto.GetStringHashHex(workedString, HashAlgorithmType);
                    //    //Console.WriteLine(HashAlgorithmType.ToString() + ": " + ReturnedString + Environment.NewLine);
                    //}

                    if (NumFreeParameters > 0)
                    {
                        for (int i = 0; i < NumFreeParameters; ++i)
                        {
                            string str = FreeParameters[i];
                            ReturnedString = null;
                            if (IsInputFormatString)
                            {
                                ReturnedString = UtilCrypto.GetStringHashHex(str, HashAlgorithmType);
                                if (ReturnedString != null)
                                {
                                    Console.WriteLine(HashAlgorithmType.ToString() + " hash of \"" + str + "\": "
                                        + Environment.NewLine + "  " + ReturnedString + Environment.NewLine);
                                }
                            }
                            else
                            {
                                byte[] bytes = null;
                                if (IsInputFormatLongInt)
                                {
                                    long val = 0;
                                    bool parsed = Util.TryParse(str, ref val);
                                    if (!parsed)
                                        ReportError("Input string does not represent an integer: \"" + str + "\".");
                                    else
                                    {
                                        Util.ToByteArray(val, ref bytes);
                                        ReturnedString = UtilCrypto.GetHashHex(bytes, HashAlgorithmType);
                                        Console.WriteLine(HashAlgorithmType.ToString() + " hash of long int " + val + ": "
                                        + Environment.NewLine + "  " + ReturnedString + Environment.NewLine);
                                    }
                                }
                                else if (IsInputFormatHex)
                                {
                                    bytes = Util.FromHexString(str);
                                    ReturnedString = UtilCrypto.GetHashHex(bytes, HashAlgorithmType);
                                    Console.WriteLine(HashAlgorithmType.ToString() + " hash of hex. encoded bytes " + str + ": "
                                        + Environment.NewLine + "  " + ReturnedString + Environment.NewLine);
                                }
                                else if (IsInputFormat64)
                                {
                                    bytes = Convert.FromBase64String(str);
                                    ReturnedString = UtilCrypto.GetHashHex(bytes, HashAlgorithmType);
                                    Console.WriteLine(HashAlgorithmType.ToString() + " hash of base-64 encoded bytes " + str + ": "
                                        + Environment.NewLine + "  " + ReturnedString + Environment.NewLine);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // File hashes:
                if (IsChecked)
                {
                    // File hashRet verification:
                    List<string> inputFilePaths = null;
                    GetInputFilePaths(ref inputFilePaths, true  /* enableWildcards */, true /* addRecursive */, true /* clearBefore */);
                    int numInputFiles = inputFilePaths.Count;
                    ReturnedString = null;
                    if (OutputPath != null)
                        ReportError("Redundant output file specification, not used.");
                    bool checkPassed = false;
                    if (HashValue != null)
                    {
                        // Verify a single file whose hashRet is specified by command line:
                        if (numInputFiles < 1)
                        {
                            ReportError("No files for verification specified, there should be one file.");
                            checkPassed = false;
                            ReturnedString = checkPassed.ToString();
                        }
                        else
                        {
                            if (numInputFiles > 1)
                                ReportError("More than one file specified for verification, should be one. All will be ckecked.");
                            bool passedThis = true;
                            foreach (string filePath in inputFilePaths)
                            {
                                try
                                {
                                    if (!File.Exists(filePath))
                                    {
                                        passedThis = false;
                                        ReportError("File does not exist: " + filePath);
                                    }
                                    else
                                        if (UtilCrypto.CheckFileHashHex(filePath, HashValue, HashAlgorithmType))
                                        {
                                            Console.WriteLine("File " + HashAlgorithmType.ToString() + ": OK.");
                                        }
                                        else
                                        {
                                            passedThis = false;
                                            Console.WriteLine("File " + HashAlgorithmType.ToString() + ": NOT PASSED.");
                                        }
                                }
                                catch (Exception ex)
                                {
                                    passedThis = false;
                                    ReportError("Exception thrown: " + ex.Message);
                                }
                            }
                            checkPassed = passedThis;
                            ReturnedString = checkPassed.ToString();
                        }
                    }
                    else
                    {
                        // Verification of mutiple file hashes from a file:
                        bool passedThis = true;
                        if (OutputPath != null)
                            ReportError("Redundant output file specification, not used.");
                        if (numInputFiles < 1)
                        {
                            ReportError("No files containing hash information are specified.");
                            passedThis = false;
                        }
                        else
                        {
                            int numCheckedAll = 0;
                            int numPassed = 0;
                            int numNotPassed = 0;
                            for (int whichInputFile = 0; whichInputFile < numInputFiles; ++whichInputFile)
                            {
                                string inputFilePath = inputFilePaths[whichInputFile];
                                // Read hashRet value / file pairs:
                                List<string[]> hashList = null;
                                UtilCrypto.ParseHashFile(inputFilePath, ref hashList);
                                Console.WriteLine(Environment.NewLine + "From input file " + Path.GetFileName(inputFilePath) + ":");
                                int numChecked = 0;
                                if (hashList != null)
                                    numChecked = hashList.Count;
                                //if (numChecked == 0)
                                //{
                                //    Console.WriteLine("  No entries.");
                                //} else
                                {
                                    foreach (string[] pair in hashList)
                                    {
                                        string hash = pair[0];
                                        string checkedFile = pair[1];
                                        if (string.IsNullOrEmpty(hash) || string.IsNullOrEmpty(checkedFile))
                                        {
                                            if (string.IsNullOrEmpty(hash))
                                                ReportError("Hash not specified.");
                                            if (string.IsNullOrEmpty(checkedFile))
                                                ReportError("FilePath not specified.");
                                        }
                                        else
                                        {
                                            ++numCheckedAll;
                                            if (!File.Exists(checkedFile))
                                            {
                                                passedThis = false;
                                                ReportError("File does not exist: " + checkedFile);
                                                ++numNotPassed;
                                            }
                                            else
                                                if (UtilCrypto.CheckFileHashHex(checkedFile, hash, HashAlgorithmType))
                                                {
                                                    Console.WriteLine(HashAlgorithmType.ToString() + " OK: " + checkedFile);
                                                    ++numPassed;
                                                }
                                                else
                                                {
                                                    passedThis = false;
                                                    Console.WriteLine(HashAlgorithmType.ToString() + " NOT PASSED: " + checkedFile);
                                                    ++numNotPassed;
                                                }
                                        }
                                    }
                                }
                            }
                            if (numCheckedAll < 1)
                            {
                                passedThis = false;
                                Console.WriteLine("No files to check.");
                            }
                            else
                            {
                                if (numPassed < 1)
                                    Console.WriteLine("No files passed.");
                                else if (numNotPassed < 1)
                                    Console.WriteLine("All files OK.");
                                else
                                {
                                    Console.WriteLine(numPassed.ToString() + " files passed, " + numNotPassed.ToString() + " NOT PASSED.");
                                }
                            }
                        }
                        checkPassed = passedThis;
                        ReturnedString = checkPassed.ToString();
                    }
                    ReturnedString = checkPassed.ToString();
                }
                else
                {
                    // Calculation of one or more file hashes:
                    List<string> inputFilePaths = null;
                    GetInputFilePaths(ref inputFilePaths, true  /* enableWildcards */, true /* addRecursive */, true /* clearBefore */);
                    int numInputFiles = inputFilePaths.Count;
                    ReturnedString = null;

                    if (numInputFiles < 1)
                    {
                        ReportError("No files to calculate hash values were specified. Nothing to be done.");
                    }
                    else
                    {
                        List<string[]> hashes = new List<string[]>();
                        foreach (string filePath in inputFilePaths)
                        {
                            if (!File.Exists(filePath))
                            {
                                ReportError("File does not exist: " + filePath);
                            }
                            else
                            {
                                string fileHash = null;
                                try
                                {
                                    fileHash = UtilCrypto.GetFileHashHex(filePath, HashAlgorithmType);
                                    hashes.Add(new string[] { fileHash, filePath });
                                    Console.WriteLine(HashAlgorithmType.ToString() + ": " + fileHash + " " + filePath);
                                }
                                catch (Exception ex)
                                {
                                    ReportError("Exception thrown: " + ex.Message);
                                }
                            }
                        }
                        if (hashes.Count < 0)
                        {
                            ReportError("No file hashes could be calculated correctly.");
                        }
                        else
                        {
                            if (OutputPath != null)
                            {
                                // Write file hashes to the output file:
                                bool doWrite = false;
                                if (!File.Exists(OutputPath))
                                {
                                    doWrite = true;
                                }
                                else if (IsSkipOverwrites)
                                {
                                    doWrite = false;
                                }
                                else if (IsForceOverwrites)
                                {
                                    doWrite = true;
                                }
                                else
                                {
                                    Console.Write(Environment.NewLine
                                        + "Warning: Output file already exists: " + Environment.NewLine + "  " + OutputPath + Environment.NewLine + Environment.NewLine
                                        + "Do you want to overwrite the file (0/1)? ");
                                    UtilConsole.Read(ref doWrite);
                                    if (doWrite)
                                        Console.WriteLine(Environment.NewLine + "File will be overwritten." + Environment.NewLine);
                                    else
                                        Console.WriteLine(Environment.NewLine + "Writing of hashes to a file skipped." + Environment.NewLine);
                                }
                                if (doWrite)
                                {
                                    try
                                    {
                                        using (StreamWriter hashWriter = new StreamWriter(OutputPath, false /* append */, Encoding.UTF8))  // File.CreateText(OutputPath))
                                        {
                                            foreach (string[] pair in hashes)
                                            {
                                                hashWriter.WriteLine(pair[0] + " " + pair[1]);
                                            }
                                        }
                                        Console.WriteLine("Hashes written to file: " + OutputPath);
                                    }
                                    catch (Exception ex)
                                    {
                                        ReportError("Exception thrown: " + ex.Message);
                                    }
                                }
                            }
                        }
                    }
                }
            }


            return ReturnedString;
        }


        /// <summary>Executes command-line action - conversion between different representations of data.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppConvert(string appName, string[] args)
        {
            ClearAllFlags();
            IsInputFormatEqualOutputFormat = true;
            ParseCommandlineParameters(appName, args);

            // Arrrange obtained parameters: 
            if (!(IsInputFormatLongInt || IsInputFormatHex || IsInputFormat64))
                IsInputFormatString = true;
            else
                IsInputFormatString = false;

            // Action part:
            Console.WriteLine("Representation converter: " + Environment.NewLine);
            if (FreeParameters.Count < 1)
                ReportError("Nothing was input.");

            foreach (string inputString in FreeParameters)
            {
                if (IsInputFormatLongInt)
                {
                    long num = 0;
                    bool parsed = Util.TryParse(inputString, ref num);
                    if (!parsed)
                        ReportError("The following input is not an integer\": " + inputString + "\".");
                    else
                    {
                        Console.WriteLine();
                        byte[] bytes = null;
                        Util.ToByteArray(num, ref bytes);
                        Console.WriteLine();
                        Console.WriteLine("Integer:         " + num);
                        Console.WriteLine("Hexadecimal:     " + Util.ToHexString(bytes));
                        Console.WriteLine("With separators: " + Util.ToHexString(bytes, "-"));
                        ReturnedString = Util.ToHexString(bytes, "-");
                    }
                }
                if (IsInputFormatHex)
                {
                    try
                    {
                        byte[] bytes = Util.FromHexString(inputString);
                        ReturnedString = Convert.ToBase64String(bytes);
                        Console.WriteLine();
                        Console.WriteLine("Byte array in hexadecimal format: "
                            + Environment.NewLine + "  " + inputString);
                        Console.WriteLine("Written with separators: "
                            + Environment.NewLine + "  " + Util.ToHexString(bytes, "="));
                        Console.WriteLine("Base-64: " + Convert.ToBase64String(bytes));
                        Console.WriteLine("Converted to string (UTF-8): " + Encoding.UTF8.GetString(bytes));
                    }
                    catch (Exception ex)
                    {
                        ReportError("Invalid format of byte array in hexadecimal notation: " + inputString
                            + Environment.NewLine + "  Error message: " + ex.Message);
                    }
                }
                if (IsInputFormat64)
                {
                    try
                    {
                        byte[] bytes = Convert.FromBase64String(inputString);
                        ReturnedString = Util.ToHexString(bytes, "-");
                        Console.WriteLine();
                        Console.WriteLine("Byte array in Base-64 representation: "
                            + Environment.NewLine + "  " + Convert.ToBase64String(bytes));
                        Console.WriteLine("Hexadecimal: "
                            + Environment.NewLine + "  " + Util.ToHexString(bytes));
                        Console.WriteLine("With separator: "
                            + Environment.NewLine + "  " + Util.ToHexString(bytes, "-"));
                        Console.WriteLine("Converted to string (UTF-8): "
                            + Environment.NewLine + "  \"" + Encoding.UTF8.GetString(bytes) + "\"");
                    }
                    catch (Exception ex)
                    {
                        ReportError("Invalid format of byte array in Base-64 notation: " + inputString
                            + Environment.NewLine + "  Error message: " + ex.Message);
                    }

                }
                if (!(IsInputFormatLongInt || IsInputFormatHex || IsInputFormat64))
                {
                    // we had an ordinary string input:
                    try
                    {
                        byte[] bytes = Encoding.UTF8.GetBytes(inputString);  // UtilCrypto.StringEncoding.GetBytes(inputString);
                        ReturnedString = Convert.ToBase64String(bytes);
                        Console.WriteLine();
                        Console.WriteLine("String: \"" + inputString + "\".");
                        Console.WriteLine("Converted to byte array (UTF-8 encoding): ");
                        Console.WriteLine("In Base-64 representation: "
                            + Environment.NewLine + "  " + Convert.ToBase64String(bytes));
                        Console.WriteLine("Hexadecimal: "
                            + Environment.NewLine + "  " + Util.ToHexString(bytes));
                        Console.WriteLine("With separator: "
                            + Environment.NewLine + "  " + Util.ToHexString(bytes, "-"));
                        Console.WriteLine("Converted back to string (UTF-8): "
                            + Environment.NewLine + "  \"" + Encoding.UTF8.GetString(bytes) + "\"");
                    }
                    catch (Exception ex)
                    {
                        ReportError("String could not be converted to byte array: " + inputString
                            + Environment.NewLine + "  Error message: " + ex.Message);
                    }
                }
                Console.WriteLine();
            }
            return ReturnedString;

        }  // AppConvert()



        /// <summary>Executes command-line action - deletion of eventual redundant files that remained 
        /// in the file system after cryptographic operations..</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppCleanFiles(string appName, string[] args)
        {

            ClearAllFlags();
            // IsInputFormatEqualOutputFormat = true;
            ParseCommandlineParameters(appName, args);



            {
                // Cleaning of one or more files:
                List<string> inputFilePaths = null;
                GetInputFilePaths(ref inputFilePaths, true  /* enableWildcards */, true /* addRecursive */, true /* clearBefore */);
                int numInputFiles = inputFilePaths.Count;
                ReturnedString = null;
                if (numInputFiles < 1)
                {
                    ReportError("No files eligible for cleaning operations. Nothing to be done.");
                }
                else
                {
                    List<string> filesToDelete = new List<string>();
                    bool answerDelete = false;
                    int numAnswersDelete = 0;
                    bool rememberAnswerDelete = false;
                    for (int whichFile = 0; whichFile < numInputFiles; ++whichFile)
                    {
                        filesToDelete.Clear();
                        string filePath = inputFilePaths[whichFile];
                        // For each file in the list, find its associated files (that may be the original file, the 
                        // encrypted file, or the decrypted file - when the last are stored as original file with 
                        // special extension appended):
                        string fileExtension = Path.GetExtension(filePath);
                        string originalFilePath = null;
                        string encryptedFilePath = null;
                        string decryptedFilePath = null;
                        if (fileExtension == CC.FileExtensionEncrypted)
                        {
                            string fileDir = Path.GetDirectoryName(filePath);
                            string filenameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
                            originalFilePath = Path.Combine(fileDir, filenameWithoutExtension);
                            encryptedFilePath = filePath;
                            decryptedFilePath = originalFilePath +  CC.FileExtensionDecrypted;
                        } else if (fileExtension == CC.FileExtensionDecrypted)
                        {
                            string fileDir = Path.GetDirectoryName(filePath);
                            string filenameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
                            originalFilePath = Path.Combine(fileDir, filenameWithoutExtension);
                            decryptedFilePath = filePath;
                            encryptedFilePath = originalFilePath + CC.FileExtensionEncrypted;
                        } else
                        {
                            originalFilePath = filePath;
                            encryptedFilePath = originalFilePath + CC.FileExtensionEncrypted;
                            decryptedFilePath = originalFilePath + CC.FileExtensionDecrypted;
                        }

                        // Check which files would be eligible for deletion:
                        bool deleteOriginal = false;
                        bool deleteEncrypted = false;
                        bool deleteDecrypted = false;
                        bool existsOriginal = File.Exists(originalFilePath);
                        bool existsEncrypted = File.Exists(encryptedFilePath);
                        bool existsDecrypted = File.Exists(decryptedFilePath);

                        // Determine, according to commandline parameters, which files are eligible for deletion,
                        // and add those files to the list:
                        if (IsDeleteDecrypted && existsDecrypted)
                        {
                            if (existsOriginal || existsEncrypted)
                            {
                                deleteDecrypted = true;
                                filesToDelete.Add(decryptedFilePath);
                            } else
                            {
                                if (IsDeleteAllVersions)
                                    deleteDecrypted = true;
                                else
                                    ReportWarning("Skipped (no remaining versions): " + decryptedFilePath);
                            }
                        }
                        if (IsDeleteEncrypted && existsEncrypted)
                        {
                            if (existsOriginal)
                            {
                                deleteEncrypted = true;
                                filesToDelete.Add(encryptedFilePath);
                            } else
                            {
                                if (IsDeleteAllVersions)
                                    deleteEncrypted = true;
                                else
                                    ReportWarning("Skipped (no remaining versions): " + decryptedFilePath);
                            }
                        }
                        if (IsDeleteOriginal && existsOriginal)
                        {
                            if (existsEncrypted && !deleteEncrypted)
                            {
                                deleteOriginal = true;
                                filesToDelete.Add(originalFilePath);
                            } else
                            {

                                if (IsDeleteAllVersions)
                                    deleteOriginal = true;
                                else
                                    ReportWarning("Skipped (no remaining versions): " + originalFilePath);
                            }
                        }
                        //if (! (deleteOriginal || deleteEncrypted || deleteDecrypted))
                        //{
                        //    ReportInfo("All versions skipped: " + filePath);
                        //}
                        // In the set of files associated with the specific input file, delete those that are 
                        // eligible for deletion (i.e., files on deletion list). Take into account the necessary 
                        //user confirmations:
                        int numCurrentInputFiles = inputFilePaths.Count;

                        for (int whichDeletedFile = 0; whichDeletedFile < filesToDelete.Count; ++whichDeletedFile)
                        {
                            string deletedFilePath = filesToDelete[whichDeletedFile];
                            {
                                bool doDelete = false;
                                // Decide whether to delete the original (input) file:
                                if (IsSkipDeletes)
                                {
                                    doDelete = false;
                                }
                                else if (IsForceDeletes)
                                {
                                    doDelete = true;
                                }
                                else
                                {
                                    if (rememberAnswerDelete)
                                    {
                                        doDelete = answerDelete;
                                    }
                                    else
                                    {
                                        // Ask whether to delete a file:
                                        Console.Write(Environment.NewLine
                                            + "Warning: File will be deleted: " + Environment.NewLine + "  " + deletedFilePath
                                            + Environment.NewLine + Environment.NewLine
                                            + "Do you really want to delete the file (0/1)? ");
                                        UtilConsole.Read(ref answerDelete);
                                        doDelete = answerDelete;

                                        //if (doDelete)
                                        //    Console.WriteLine(Environment.NewLine + "File will be deleted." + Environment.NewLine);
                                        //else
                                        //    Console.WriteLine(Environment.NewLine + "File deletion will be skipped." + Environment.NewLine);

                                        ++numAnswersDelete;
                                        if (numAnswersDelete == 1 && numCurrentInputFiles > whichFile + 1)
                                        {
                                            Console.Write(Environment.NewLine + "Use this decision for deletion of all files on the list (0/1)? ");
                                            UtilConsole.Read(ref rememberAnswerDelete);
                                            if (rememberAnswerDelete)
                                            {
                                                Console.WriteLine();
                                                if (answerDelete)
                                                    Console.WriteLine("Further files from the list will be automatically deleted.");
                                                else
                                                    Console.WriteLine("Deletion of further files from the list will be skipped.");
                                            }
                                        }
                                    }
                                }
                                if (doDelete)
                                {
                                    try
                                    {
                                        File.Delete(deletedFilePath);
                                        ReportInfo("Deleted: " + deletedFilePath);
                                    }
                                    catch (Exception ex) {
                                        ReportError("File could not be deleted: " + deletedFilePath + Environment.NewLine
                                            + "  Error message: " + ex.Message);
                                    }
                                }

                            }


                        }  // deletion of eligible files associated with the specified file

                    }  // iterate over list of specified files
                }
            }
            return ReturnedString;
        }  // AppCleanFiles()  
        


        /// <summary>Executes command-line action - measuring time of password generaton algorithms.</summary>
        /// <remarks>Key generation algorithm type and other parameters such as password and salt are determined by
        /// command-line options.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppTimeKeyGeneration(string appName, string[] args)
        {
            return AppKeyGenerationAll(appName, args, true /* measureTimes */, 1 /* numGenerations */);
        }


        /// <summary>Executes command-line action - generates a random initialization vector for symmetric encryption.</summary>
        /// <remarks>Key generation algorithm type and other parameters such as password and salt are determined by
        /// command-line options.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppGetKey(string appName, string[] args)
        {
            return AppKeyGenerationAll(appName, args, false /* measureTimes */, 1 /* numGenerations */);
        }

        /// <summary>Executes command-line action - generates a random initialization vector for symmetric encryption.</summary>
        /// <remarks>Key generation algorithm type and other parameters such as password and salt are determined by
        /// command-line options.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppGetInitializationVector(string appName, string[] args)
        {
            return AppKeyGenerationAll(appName, args, false /* measureTimes */, 2 /* numGenerations */);
        }

        /// <summary>Executes command-line action - generates a random salt bytes.</summary>
        /// <remarks>Key generation algorithm type and other parameters such as password and salt are determined by
        /// command-line options.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppGetSalt(string appName, string[] args)
        {
            return AppKeyGenerationAll(appName, args, false /* measureTimes */, 3 /* numGenerations */);
        }


        /// <summary>Resolves password related parameters such as password, salt, and generated key length.</summary>
        /// <remarks>
        /// <para>Paremeters that determine which free paremeters map to password-related parameters such as key length 
        /// and number of iterations of key generation algorithm, must fill free parameters up to the specified index.</para>
        /// </remarks>
        /// <param name="whichFreeParameterkeyLength">Index of free parameter that can eventually represent the key length.
        /// If less than 0 then key length can not be specified by free parameters.</param>
        /// <param name="whichFreeParameterNumIterations">Index of free parameter that can eventually represent the number
        /// of iterations in password generating algorithm. If less than 0 then number of key generation iterations can not 
        /// be specified by free parameters.</param>
        /// <returns>Number of free parameters that were eventually used for resolving password-related parameters.</returns>
        public virtual int ResolvePasswordParameters(int whichFreeParameterkeyLength = 0, int whichFreeParameterNumIterations = 1)
        {

            int numFreeParametersUsed = 0;

            if (KeyLength <= 0)
            {
                if (whichFreeParameterkeyLength >= 0 && NumFreeParameters > whichFreeParameterkeyLength)
                {
                    string str = FreeParameters[whichFreeParameterkeyLength];
                    bool successful = Util.TryParse(str, ref KeyLength);
                    if (successful)
                    {
                        ++numFreeParametersUsed;
                        if (KeyLength <= 0)
                            ReportError("Key length specified by a free parameter should be greater than 0.");
                    }
                    else
                        ReportError("Invalid format for key length: \"" + str + "\"");
                }
                if (KeyLength <= 0)
                {
                    KeyLength = CC.DefaultKeyLength;
                    ReportWarning("Default key length was used: " + KeyLength + ".");
                }
            }
            if (NumPasswordIterations <= 0)
            {
                if (whichFreeParameterNumIterations >= 0 && NumFreeParameters > whichFreeParameterNumIterations)
                {
                    string str = FreeParameters[whichFreeParameterNumIterations];
                    bool successful = Util.TryParse(str, ref NumPasswordIterations);
                    if (successful)
                    {
                        ++numFreeParametersUsed;
                        if (NumPasswordIterations <= 0)
                            ReportError("Number of key generator iterations specified by a free parameter should be greater than 0.");
                    }
                    else
                        ReportError("Invalid format for numberr of key generator iterations: \"" + str + "\"");
                }
                if (NumPasswordIterations <= 0)
                {
                    NumPasswordIterations = CC.DefaultNumPasswordIterations;
                    ReportWarning("Default number of key generation iterations was used: " + NumPasswordIterations + ".");
                }
            }
            if (PasswordString == null && PasswordBytes == null)
            {
                if (PasswordLength <= 0)
                {
                    if (KeyLength > 0)
                        PasswordLength = KeyLength;
                    else
                        PasswordLength = CC.DefaultPasswordLength;
                }
                if (PasswordLength > 0)
                {
                    PasswordBytes = UtilCrypto.GetRandomBytes(PasswordLength);
                    Console.WriteLine(Environment.NewLine + "Password has been randomly generated: length = "
                        + PasswordLength + ", " + Environment.NewLine
                        + "  pwd (base-64): " + Convert.ToBase64String(PasswordBytes));
                }
                else
                    ReportError("Password (as string or byte array) or its length is not specified.");
            }
            else if (PasswordBytes == null && PasswordString != null)
                PasswordBytes = UtilCrypto.StringEncoding.GetBytes(PasswordString);
            if (SaltString == null && SaltBytes == null)
            {
                if (SaltLength <= 0)
                {
                    if (KeyLength > 0)
                        SaltLength = KeyLength;
                    else if (PasswordLength > 0)
                        SaltLength = PasswordLength;
                    else
                        SaltLength = CC.DefaultSaltLength;
                }
                if (SaltLength > 0)
                {
                    SaltBytes = UtilCrypto.GetRandomBytes(SaltLength);
                    Console.WriteLine(Environment.NewLine + "Salt has been randomly generated: length = "
                        + SaltLength + ", " + Environment.NewLine
                        + "  salt (base-64): " + Convert.ToBase64String(SaltBytes));
                }
                else
                    ReportError("Salt (as string or byte array) or its length is not specified.");
            }
            else if (SaltBytes == null && SaltString != null)
                SaltBytes = UtilCrypto.StringEncoding.GetBytes(SaltString);
            if (PasswordLength == 0)
            {
                if (PasswordBytes != null)
                    PasswordLength = PasswordBytes.Length;
            }
            if (SaltLength == 0)
            {
                if (SaltBytes != null)
                    SaltLength = SaltBytes.Length;
            }
            if (KeyLength == 0)
            {
                KeyLength = PasswordBytes.Length;
                Console.WriteLine("Length of the generated key was determined form password length: " + PasswordLength + ".");
            }
            return numFreeParametersUsed;
        }  // ResolvePasswordParameters()


        /// <summary>Executes command-line action - one of the actions related to key generation.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        /// <param name="measureTimes">If true then time necessary for key generation with given parameters is measured.
        /// Otherwise, the key is actually created. The key can also be used as initialization vector.</param>
        /// <param name="numGenerations">Number of repetirions of key algorithm before return. This makes possible to to
        /// generate different outputs e.g. for key, for initialization vector, or for salt.</param>
        protected virtual string AppKeyGenerationAll(string appName, string[] args, bool measureTimes, int numGenerations)
        {
            ClearAllFlags();
            SetFlags(CryptoFlags.KeyGeneration);
            ParseCommandlineParameters(appName, args);

            //if (this.NumAppArguments < 1)
            //    throw new ArgumentException("There should be at least 1 argument (file whose hashRet value is calculated).");

            // Arrrange obtained parameters: 
            PasswordAlgorithmType = PasswordAlgorithmType.Default;
            if (!string.IsNullOrEmpty(PasswordAlgorithmTypeString))
                PasswordAlgorithmType = UtilCrypto.GetPasswordAlgorithmType(PasswordAlgorithmTypeString);
            else if (!string.IsNullOrEmpty(AlgorithmTypeString))
                PasswordAlgorithmType = UtilCrypto.GetPasswordAlgorithmType(AlgorithmTypeString);


            int numFreeParametersUsed = 0;

            // Resolve password parameters:
            if (true)
            {

                numFreeParametersUsed += ResolvePasswordParameters(0 /* whichFreeParameterkeyLength */,
                    1 /* whichFreeParameterNumIterations */);
                if (NumFreeParameters - numFreeParametersUsed > 0)
                    ReportError("There were " + (NumFreeParameters - numFreeParametersUsed) + " redundant parameters in command-line.");
            }

            //else
            //{
            //    numFreeParametersUsed = 0;
            //    if (KeyLength <= 0)
            //    {
            //        if (NumFreeParameters > 0)
            //        {
            //            string str = FreeParameters[0];
            //            bool successful = Util.TryParse(str, ref KeyLength);
            //            if (successful)
            //            {
            //                ++numFreeParametersUsed;
            //                if (KeyLength <= 0)
            //                    ReportError("Key length specified by a free parameter should be greater than 0.");
            //            }
            //            else
            //                ReportError("Invalid format for key length: \"" + str + "\"");
            //        }
            //        if (KeyLength <= 0)
            //        {
            //            KeyLength = CC.DefaultKeyLength;
            //            ReportWarning("Default key length was used: " + KeyLength + ".");
            //        }
            //    }
            //    if (NumPasswordIterations <= 0)
            //    {
            //        if (NumFreeParameters > 1)
            //        {
            //            string str = FreeParameters[1];
            //            bool successful = Util.TryParse(str, ref NumPasswordIterations);
            //            if (successful)
            //            {
            //                ++numFreeParametersUsed;
            //                if (NumPasswordIterations <= 0)
            //                    ReportError("Number of key generator iterations specified by a free parameter should be greater than 0.");
            //            }
            //            else
            //                ReportError("Invalid format for numberr of key generator iterations: \"" + str + "\"");
            //        }
            //        if (NumPasswordIterations <= 0)
            //        {
            //            NumPasswordIterations = CC.DefaultNumPasswordIterations;
            //            ReportWarning("Default number of key generation iterations was used: " + NumPasswordIterations + ".");
            //        }
            //    }
            //    if (NumFreeParameters - numFreeParametersUsed > 0)
            //        ReportError("There were " + (NumFreeParameters - numFreeParametersUsed) + " redundant parameters in command-line.");
            //    if (PasswordString == null && PasswordBytes == null)
            //    {
            //        if (PasswordLength <= 0)
            //        {
            //            if (KeyLength > 0)
            //                PasswordLength = KeyLength;
            //            else
            //                PasswordLength = CC.DefaultPasswordLength;
            //        }
            //        if (PasswordLength > 0)
            //        {
            //            PasswordBytes = UtilCrypto.GetRandomBytes(PasswordLength);
            //            Console.WriteLine(Environment.NewLine + "Password has been randomly generated: length = "
            //                + PasswordLength + ", " + Environment.NewLine
            //                + "  pwd (base-64): " + Convert.ToBase64String(PasswordBytes));
            //        }
            //        else
            //            ReportError("Password (as string or byte array) or its length is not specified.");
            //    }
            //    else if (PasswordBytes == null && PasswordString != null)
            //        PasswordBytes = UtilCrypto.StringEncoding.GetBytes(PasswordString);
            //    if (SaltString == null && SaltBytes == null)
            //    {
            //        if (SaltLength <= 0)
            //        {
            //            if (KeyLength > 0)
            //                SaltLength = KeyLength;
            //            else if (PasswordLength > 0)
            //                SaltLength = PasswordLength;
            //            else
            //                SaltLength = CC.DefaultSaltLength;
            //        }
            //        if (SaltLength > 0)
            //        {
            //            SaltBytes = UtilCrypto.GetRandomBytes(SaltLength);
            //            Console.WriteLine(Environment.NewLine + "Salt has been randomly generated: length = "
            //                + SaltLength + ", " + Environment.NewLine
            //                + "  salt (base-64): " + Convert.ToBase64String(SaltBytes));
            //        }
            //        else
            //            ReportError("Salt (as string or byte array) or its length is not specified.");
            //    }
            //    else if (SaltBytes == null && SaltString != null)
            //        SaltBytes = UtilCrypto.StringEncoding.GetBytes(SaltString);
            //    if (PasswordLength == 0)
            //    {
            //        if (PasswordBytes != null)
            //            PasswordLength = PasswordBytes.Length;
            //    }
            //    if (SaltLength == 0)
            //    {
            //        if (SaltBytes != null)
            //            SaltLength = SaltBytes.Length;
            //    }
            //    if (KeyLength == 0)
            //    {
            //        KeyLength = PasswordBytes.Length;
            //        Console.WriteLine("Length of the generated key was determined form password length: " + PasswordLength + ".");
            //    }

            //}




            // Action part:

            // Prepare the algorithm:
            PasswordAlgorithm = UtilCrypto.GetPasswordAlgorithm(PasswordAlgorithmType);
            PasswordAlgorithm.Init(PasswordBytes, SaltBytes, NumPasswordIterations);

            string whatIsGenerated = null;

            if (measureTimes)
                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Testing time requirements of the key generation algorithm...");
            else
            {
                if (numGenerations == 1)
                    whatIsGenerated = "secret key";
                else if (numGenerations == 2)
                    whatIsGenerated = "initialization vector";
                else if (numGenerations > 2)
                    whatIsGenerated = "salt";
                else
                    ReportError("Number or generations of the algorithm (distinguished from number of iterations) is less than or equal to 0.");
                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Generating {0}, num. generations = {1} ...",
                    whatIsGenerated, numGenerations);
            }
            Console.WriteLine("  Algorithm type:  " + PasswordAlgorithmType);
            Console.WriteLine("  Password length: " + PasswordBytes.Length);
            Console.WriteLine("  Salt length:     " + SaltBytes.Length);
            Console.WriteLine("  Key length:      " + KeyLength);
            Console.WriteLine("  Iterations:      " + NumPasswordIterations);

            Console.WriteLine();
            int outputLevel = 0;  // level of output from the time measurement function 
            double averageExecutionTime, averageCpuTime;
            int numInitialExecutions = 1;

            //Console.WriteLine("Password: " + Util.ToHexString(PasswordBytes));
            //Console.WriteLine("Salt    : " + Util.ToHexString(SaltBytes));

            if (measureTimes)
            {
                int numExecutions = StopWatch1.TestExecutionTime(
                    () =>
                    {
                        PasswordAlgorithm.Init(PasswordBytes, SaltBytes, NumPasswordIterations);
                        byte[] generatedKey = PasswordAlgorithm.GetBytes(KeyLength);
                    },
                    out averageExecutionTime, out averageCpuTime,
                    TargetedTotalTime, outputLevel, numInitialExecutions);

                Console.WriteLine(Environment.NewLine + "... test complete, duration: " + (numExecutions * averageExecutionTime) + " s (CPU: "
                    + numExecutions * averageCpuTime + "s)." + Environment.NewLine);
                Console.WriteLine("Executions per second:  " + 1.0 / averageExecutionTime + " (CPU: " + 1.0 / averageCpuTime + ")" + Environment.NewLine);
                Console.WriteLine("Average execution time: " + averageExecutionTime + " (CPU: " + averageCpuTime + ")");
                Console.WriteLine();

                ReturnedString = averageCpuTime.ToString();
            }
            else
            {
                PasswordAlgorithm.Init(PasswordBytes, SaltBytes, NumPasswordIterations);

                byte[] generatedKey = null;
                for (int i = 0; i < numGenerations; ++i)
                {
                    generatedKey = PasswordAlgorithm.GetBytes(KeyLength);
                }
                KeyBytes = generatedKey;
                string keyHex = Util.ToHexString(generatedKey);
                string keyBase64 = Convert.ToBase64String(generatedKey);
                Console.WriteLine("Generated " + whatIsGenerated + " in hexadecimal format: " + Environment.NewLine
                    + "  " + keyHex + Environment.NewLine);
                Console.WriteLine("Generated " + whatIsGenerated + " in base-64 encoding: " + Environment.NewLine
                    + "  " + keyBase64 + Environment.NewLine);
                if (IsOutputFormat64)
                    ReturnedString = keyBase64;
                else if (IsOutputFormatHex)
                    ReturnedString = keyHex;
                else if (IsInputFormat64)
                    ReturnedString = keyBase64;
                else if (IsInputFormatHex)
                    ReturnedString = keyHex;
                else
                    ReturnedString = keyBase64;  // default format for keys
            }

            return ReturnedString;
        }  // AppTimeKeyGeneration


        /// <summary>Resolves asymmetric algorithm parameters from the information that has been previously
        /// obtained through command-line parameters.</summary>
        public virtual void ResolveAsymParameters()
        {
            AsymmetricAlgorithm alg = UtilCrypto.GetAsymmetricAlgorithm(AsymAlgorithmType, AsymKeyContainerName, AsymKeyFileXml,
                AsymFlags);
            if (alg != null)
            {
                AsymAlgorithmType = UtilCrypto.GetAsymmetricAlgorithmType(alg);
                AsymAlgorithm = alg;
            }
        }



        /// <summary>Executes command-line action - prints information about asymmetric keys specified by command-line parameters.</summary>
        /// <remarks>Information necessary to access the asymmetric keys is extracted from command-line parameters.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppAsymKeyInfo(string appName, string[] args)
        {
            ReturnedString = null;
            ClearAllFlags();
            SetFlags(CryptoFlags.AsymmetricEncryption);
            ParseCommandlineParameters(appName, args);

            ResolveAsymParameters();
            if (AsymAlgorithm == null)
                ReportError("The asymmetric algorithm keys could not be obtained.");
            else
            {
                ReturnedString = UtilCrypto.GetAsymmetricalgorithmHash(AsymAlgorithm);
                Console.WriteLine(Environment.NewLine + "Assymmetric keys information: " + Environment.NewLine
                    + "  " + UtilCrypto.ToString(AsymAlgorithm));
                string xmlString = Util.XmlToString(AsymAlgorithm.ToXmlString(IsExportPrivateKey), "  ", Environment.NewLine);
                Console.WriteLine(Environment.NewLine + "XML key information: " + Environment.NewLine
                    + xmlString + Environment.NewLine);

                if (AsymAlgorithm is DSA)
                {
                    Console.WriteLine(Environment.NewLine + "DSA, encryption/decryption not implemented." + Environment.NewLine);
                } else
                {
                    // Test encryption / decryption with the asymmetric keys:
                    string errorStr = null;
                    bool encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", out errorStr,
                        AsymAlgorithm, null /* encryption same as decryption */);
                    Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.")); 
                    if (errorStr != null)
                        Console.WriteLine("Error when encrypt/decrypt: " + errorStr);
                    if (encryptionTestPassed)
                    {
                        int maxLength = UtilCrypto.GetMaximalAsymmetricTextLength(AsymAlgorithm);
                        bool passedAtMax = false;
                        bool passedAboveMax = false;
                        string errorAtMax = null;
                        string errorAboveMax = null;
                        passedAtMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength, out errorAtMax, AsymAlgorithm, null /* encryption same as decryption */);
                        passedAboveMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength + 1, out errorAboveMax, AsymAlgorithm, null /* encryption same as decryption */);
                        if (passedAtMax && !passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Maximal original length (confirmed by test): " + maxLength);
                        } else if (!passedAtMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test failed at theoretical maximal length (" + maxLength + ")."
                                + Environment.NewLine + "  Error message: " + errorAtMax);
                        } else if (passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test passed above theoretical maximal length (" + maxLength + ").");
                        }
                    }
                    Console.WriteLine();
                }
            }
            return ReturnedString;
        }


        /// <summary>Executes command-line action - exports asymmetric keys specified by command-line parameters.</summary>
        /// <remarks>Information necessary to access the asymmetric keys is extracted from command-line parameters.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppAsymExportKey(string appName, string[] args)
        {
            ReturnedString = null;
            ClearAllFlags();
            SetFlags(CryptoFlags.AsymmetricEncryption);
            ParseCommandlineParameters(appName, args);

            ResolveAsymParameters();
            if (AsymAlgorithm == null)
                ReportError("The asymmetric algorithm keys could not be obtained.");
            else
            {
                ReturnedString = UtilCrypto.GetAsymmetricalgorithmHash(AsymAlgorithm);
                Console.WriteLine(Environment.NewLine + "Exporting asymmetric keys ...");
                Console.WriteLine(Environment.NewLine + "Assymmetric keys information: " + Environment.NewLine
                    + "  " + UtilCrypto.ToString(AsymAlgorithm));
                string xmlString = Util.XmlToString(AsymAlgorithm.ToXmlString(false /* exportPrivateKey */), "  ", Environment.NewLine);
                Console.WriteLine(Environment.NewLine + "XML key information: " + Environment.NewLine
                    + xmlString + Environment.NewLine);

                // Test encryption / decryption with the asymmetric keys:
                string errorStr = null;
                bool encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", out errorStr,
                    AsymAlgorithm, null /* encryption same as decryption */);
                Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                    + (encryptionTestPassed ? "passed. " : "NOT passed.")); 
                if (errorStr != null)
                    Console.WriteLine("Error when encrypt/decrypt: " + errorStr);

                if (encryptionTestPassed)
                    {
                        int maxLength = UtilCrypto.GetMaximalAsymmetricTextLength(AsymAlgorithm);
                        bool passedAtMax = false;
                        bool passedAboveMax = false;
                        string errorAtMax = null;
                        string errorAboveMax = null;
                        passedAtMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength, out errorAtMax, AsymAlgorithm, null /* encryption same as decryption */);
                        passedAboveMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength + 1, out errorAboveMax, AsymAlgorithm, null /* encryption same as decryption */);
                        if (passedAtMax && !passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Maximal original length (confirmed by test): " + maxLength);
                        } else if (!passedAtMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test failed at theoretical maximal length (" + maxLength + ")."
                                + Environment.NewLine + "  Error message: " + errorAtMax);
                        } else if (passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test passed above theoretical maximal length (" + maxLength + ").");
                        }
                    }
                Console.WriteLine();
                if (NumFreeParameters < 1)
                    ReportError("Export location (file) for asymmetric keys is not specified.");
                else
                {
                    if (NumFreeParameters > 1)
                        ReportWarning("There are redundant export locations. Only the first one will be used.");
                    string outputFilePath = FreeParameters[0];
                    bool doWrite = false;
                    if (!File.Exists(outputFilePath))
                    {
                        doWrite = true;
                    }
                    else
                    {
                        // Ouptut file already exist, decide whether to overwrite it:
                        if (IsSkipOverwrites)
                        {
                            doWrite = false;
                        }
                        else if (IsForceOverwrites)
                        {
                            doWrite = true;
                        }
                        else
                        {
                            // Ask whether to overwrite the file:
                            Console.Write(Environment.NewLine
                                + "Warning: Output file already exists: " + Environment.NewLine + "  " + outputFilePath
                                + Environment.NewLine + Environment.NewLine
                                + "Do you want to overwrite the file (0/1)? ");
                            UtilConsole.Read(ref doWrite);

                        }
                    }
                    if (doWrite)
                    {
                        if (File.Exists(outputFilePath))
                            ReportWarning("Overwritten: " + outputFilePath);
                        string xmlStr = null;
                        if (IsExportPrivateKey)
                            xmlStr = Util.XmlToString(AsymAlgorithm.ToXmlString(true /* exportPrivateKey */));
                        else
                            xmlStr = Util.XmlToString(AsymAlgorithm.ToXmlString(false /* exportPrivateKey */));
                        File.WriteAllText(outputFilePath, xmlStr);
                        if (IsExportPrivateKey)
                            Console.WriteLine("Asymmetric keys (including private) were exported to " + Environment.NewLine 
                                + "  " + outputFilePath);
                        else
                            Console.WriteLine("Asymmetric key (just public part) was exported to " + Environment.NewLine
                                + "  " + outputFilePath);
                    }
                }

            }
            return ReturnedString;
        }


        /// <summary>Executes command-line action - prints information about the certificate specified by command-line parameters.</summary>
        /// <remarks>Information necessary to access the asymmetric keys is extracted from command-line parameters.</remarks>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppCertInfo(string appName, string[] args)
        {
            ReturnedString = null;
            ClearAllFlags();
            SetFlags(CryptoFlags.AsymmetricEncryption);
            ParseCommandlineParameters(appName, args);

            if (CertificatePath != null)
            {
                string privateKeyPassword = null;
                if (IsCertificatePasswordThroughUi)
                {
                    Console.Write(Environment.NewLine + "Insert certificate password (<Enter> for none): ");
                    UtilConsole.ReadPwd(ref privateKeyPassword);
                    if (!string.IsNullOrEmpty(privateKeyPassword))
                        CertificatePassword = privateKeyPassword;
                }
                X509Certificate2 cert = new X509Certificate2(CertificatePath, CertificatePassword); // X509Certificate2.CreateFromFile();
                    //new X509Certificate2();

                if (cert == null)
                {
                    ReportError("Could not create a certificate on basis of provided data.");
                }
                else
                {

                    // We will return hash of the public key:
                    AsymmetricAlgorithm algPublic = cert.PublicKey.Key;
                    if (algPublic != null)
                        ReturnedString = UtilCrypto.GetAsymmetricalgorithmHash(algPublic);

                    Console.WriteLine(Environment.NewLine + "Certificate informaton:" + Environment.NewLine
                        + UtilCrypto.ToString(cert) + Environment.NewLine);

                    string detailedCertStr = cert.ToString(true);
                    string certStr = cert.ToString(false);


                    // Test encryption / decryption with the asymmetric keys:


                    if (algPublic is DSA)
                    {
                        Console.WriteLine(Environment.NewLine + "DSA, encryption/decryption not implemented." + Environment.NewLine);
                    }
                    else
                    {
                        bool encryptionTestPassed = false;
                        AsymmetricAlgorithm algPrivate = cert.PrivateKey;
                        string errorStr = null;
                        encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", out errorStr, algPublic, algPrivate);
                        Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                            + (encryptionTestPassed ? "passed. " : "NOT passed."));
                        if (errorStr != null)
                            Console.WriteLine("Error when encrypt/decrypt: " + errorStr);
                    if (encryptionTestPassed)
                    {
                        int maxLength = UtilCrypto.GetMaximalAsymmetricTextLength(AsymAlgorithm);
                        bool passedAtMax = false;
                        bool passedAboveMax = false;
                        string errorAtMax = null;
                        string errorAboveMax = null;
                        passedAtMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength, out errorAtMax, algPublic, algPrivate);
                        passedAboveMax = UtilCrypto.AsymEncryptionDecryptionTest(maxLength + 1, out errorAboveMax, algPublic, algPrivate);
                        if (passedAtMax && !passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Maximal original length (confirmed by test): " + maxLength);
                        } else if (!passedAtMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test failed at theoretical maximal length (" + maxLength + ")."
                                + Environment.NewLine + "  Error message: " + errorAtMax);
                        } else if (passedAboveMax)
                        {
                            Console.WriteLine(Environment.NewLine + "Encrypton/decryption test passed above theoretical maximal length (" + maxLength + ").");
                        }
                    }
                        Console.WriteLine();
                    }

                    //Console.WriteLine(Environment.NewLine + Environment.NewLine
                    //    + "Certificate - very short description: " + Environment.NewLine + Environment.NewLine
                    //    + cert.ToString() + Environment.NewLine);

                    //Console.WriteLine(Environment.NewLine + Environment.NewLine
                    //    + "Certificate - short description: " + Environment.NewLine + Environment.NewLine
                    //    + cert.ToString(false) + Environment.NewLine);

                    //Console.WriteLine(Environment.NewLine + Environment.NewLine
                    //    + "Certificate - long description: " + Environment.NewLine + Environment.NewLine
                    //    + cert.ToString(true) + Environment.NewLine);


                    //string strXml = null;
                    //strXml = cert.ToXmlString(false);
                }


            }


            return ReturnedString;
        }


        /// <summary>Executes command-line action - a couple of custom asymmetric encryption-related tests.</summary>
        /// <param name="appName">Name of the embedded application.</param>
        /// <param name="args">Arguments of the embedded application's command.</param>
        public virtual string AppAsymTest(string appName, string[] args)
        {
            bool saveKeys = true;
            bool speedAndLengthTest = true;

            ReturnedString = null;
            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Asymmetric algorithm tests ... " + Environment.NewLine);

            string containerNameNoDelete = "IGLibTestContainer11";
            string containerName = "IGLibTestContainer11";

            RSACryptoServiceProvider rsa = null;
            AsymmetricAlgorithm alg = null;

            string originalString = "This is the original string to encrypt.";
            byte[] originalBytes; // = UtilCrypto.StringEncoding.GetBytes(originalString);
            byte[] encryptedBytes = null;
            string encryptedString = null;
            byte[] decryptedBytes = null;
            string decryptedString = null;


            // Generate RSA keys, not persistent:

            Console.Write(Environment.NewLine + "Generating a new NONpersistent RSA key...");
            alg = rsa = UtilCrypto.GetAsymmetricAlgorithm(Crypto.AsymmetricAlgorithmType.RSA,
                null /* containerNameNoDelete */) as RSACryptoServiceProvider;
            Console.WriteLine("  ... done. ");
            Console.WriteLine("Generated key: " + UtilCrypto.ToString(rsa));

            // Test encryption / decryption with the asymmetric keys:
            bool encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", alg, alg /* encryption same as decryption */);
            Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);

            if (speedAndLengthTest)
            {
                int length1 = 3;
                double factor = 1.555;
                int maxLength = 30000;
                bool doContinue = true;
                StopWatch1 sw = new StopWatch1();
                RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
                while (doContinue)
                {
                    byte[] orig = new Byte[length1];
                    byte[] encrypted = null;
                    byte[] decrypted = null;
                    rng.GetBytes(orig);
                    try
                    {
                        sw.Start();
                        encrypted = UtilCrypto.EncryptAsymShort(orig, alg);
                        decrypted = UtilCrypto.DecryptAsymShort(encrypted, alg);
                        sw.Stop();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("Encrypted/decrypted ERROR, length = " + length1
                            + ", msg = " + ex.Message);
                    }
                    Console.WriteLine(Environment.NewLine + "Encrypt/decript, length = " + length1 + ": t = " +
                        sw.Time + " s");
                    bool equal = Util.AreEqual(orig, decrypted);
                    if (!equal)
                    {
                        Console.WriteLine("Encrypted/decrypted NOT EQUAL to original, length = " + length1);
                        doContinue = false;
                    }
                    length1 = (int)((double)length1 * factor);
                    if (length1 > maxLength)
                        doContinue = false;
                }
            }

            {
                // Encrypt/decrypt string with the generated keys:
                Console.WriteLine(Environment.NewLine + Environment.NewLine + Environment.NewLine +
                    "ENCRYPT / DECRYPT STRINGS..." + Environment.NewLine);
                string strOrig = "Test string";
                string strEncrypted = UtilCrypto.EncryptStringAsymShort(strOrig, alg);
                string strDecrypted = UtilCrypto.DecryptStringAsymShort(strEncrypted, alg);
                Console.WriteLine("Original string: " + strOrig + Environment.NewLine +
                    "Encrypted string: " + strEncrypted + Environment.NewLine +
                    "Decrypted string: " + strDecrypted);
                if (strDecrypted != strOrig)
                {
                    Console.WriteLine(Environment.NewLine + "STRING ENCRYPTION / DECRYPTION INCORRECT!");
                }
                else
                {
                    Console.WriteLine("Decrypted string is the same as original.");
                }
                Console.WriteLine(Environment.NewLine);
            }


            // Export asymmetric keys to a file:
            if (saveKeys)
            {
                string filePath = "rsakeys_test_1.xml";
                Console.WriteLine("Saving RSA keys (including private) to " + filePath + " ...");
                string xmlString = alg.ToXmlString(true);
                xmlString = Util.XmlToString(xmlString, "  " /* indentChars */, Environment.NewLine /* newLineChars */);
                File.WriteAllText(filePath, xmlString);
                Console.WriteLine("... saving keys to XML done." + Environment.NewLine);
            }

            // Encrypt with the generated keys:

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Encrypting a string ... ");
            originalBytes = UtilCrypto.StringEncoding.GetBytes(originalString);
            encryptedBytes = rsa.Encrypt(originalBytes, false);
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            Console.WriteLine();

            // Decrypt with the generated keys:

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Decrypt encrypted ... ");
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            decryptedBytes = rsa.Decrypt(encryptedBytes, false);
            decryptedString = UtilCrypto.StringEncoding.GetString(decryptedBytes);
            Console.WriteLine("Decrypted string: \"" + decryptedString + "\"");
            Console.WriteLine(Environment.NewLine);




            // Generate PERSISTENT key (stored in key container):

            Console.Write(Environment.NewLine + "Generating a new PERSISTENT RSA key...");
            alg = rsa = UtilCrypto.GetAsymmetricAlgorithm(Crypto.AsymmetricAlgorithmType.RSA, containerNameNoDelete)
                as RSACryptoServiceProvider;
            Console.WriteLine("  ... done. ");
            Console.WriteLine("Generated PERSISTENT key: " + UtilCrypto.ToString(rsa));

            // Test encryption / decryption with the asymmetric keys:
            encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", alg, alg /* encryption same as decryption */);
            Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);


            // Export asymmetric keys to a file:
            if (saveKeys)
            {
                string filePath = "rsakeys_test_persistent.xml";
                Console.WriteLine("Saving RSA keys (including private) to " + filePath + " ...");
                string xmlString = alg.ToXmlString(true);
                xmlString = Util.XmlToString(xmlString, "  " /* indentChars */, Environment.NewLine /* newLineChars */);
                File.WriteAllText(filePath, xmlString);
                Console.WriteLine("... saving keys to XML done." + Environment.NewLine);
            }


            // Encryptand / decrypt with the PERSISTENT key:

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Encrypting a string ... ");
            originalBytes = UtilCrypto.StringEncoding.GetBytes(originalString);
            encryptedBytes = rsa.Encrypt(originalBytes, false);
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            Console.WriteLine();

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Decrypt encrypted ... ");
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            decryptedBytes = rsa.Decrypt(encryptedBytes, false);
            decryptedString = UtilCrypto.StringEncoding.GetString(decryptedBytes);
            Console.WriteLine("Decrypted string: \"" + decryptedString + "\"");
            Console.WriteLine(Environment.NewLine);

            // Encryptand / decrypt ONCE AGAIN with the PERSISTENT key (result should be different):

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Encrypting a string (SECOND TIME) ... ");
            originalBytes = UtilCrypto.StringEncoding.GetBytes(originalString);
            encryptedBytes = rsa.Encrypt(originalBytes, false);
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            Console.WriteLine();

            Console.WriteLine(Environment.NewLine + Environment.NewLine + "Decrypt encrypted (SECOND TIME) ... ");
            encryptedString = Convert.ToBase64String(encryptedBytes);
            Console.WriteLine("Original string: \"" + originalString + "\"");
            Console.WriteLine("Encrypted string (base-64): " + encryptedString);
            decryptedBytes = rsa.Decrypt(encryptedBytes, false);
            decryptedString = UtilCrypto.StringEncoding.GetString(decryptedBytes);
            Console.WriteLine("Decrypted string: \"" + decryptedString + "\"");
            Console.WriteLine(Environment.NewLine);


            if (true)
            {
                // DECRYPT the previously stored encrypted string with the PERSISTENT key (result should be the same if the
                // key was not deleted from the machine store):

                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Decrypt encrypted FROM FIRST TIME (copied encrypted base64) ... ");
                encryptedBytes = Convert.FromBase64String("IPQi4tPZe/zvQQ2RnAdJDySquOus1HdO1pmpEZum7kB6g1v+VKEWeEYpwyOWxGoXEP4mBfmaaKeYosVYeb/oCohVvJm7XcmIqmVRWm9AK9k+5+Bhc19TBeGOFq3czEtT8nVLJWL96cql5OVRppYaXIpxTxgo35o8PYKzfhhASb8=");
                encryptedString = Convert.ToBase64String(encryptedBytes);
                Console.WriteLine("Original string: \"" + originalString + "\"");
                Console.WriteLine("Encrypted string (base-64): " + encryptedString);
                decryptedBytes = rsa.Decrypt(encryptedBytes, false);
                decryptedString = UtilCrypto.StringEncoding.GetString(decryptedBytes);
                Console.WriteLine("Decrypted string: \"" + decryptedString + "\"");
                Console.WriteLine(Environment.NewLine);


                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Decrypt encrypted FROM FIRST TIME (copied encrypted base64) ... ");
                encryptedBytes = Convert.FromBase64String("qpt2UZE3O7dkjXkXqvAMGIRaLAOmTxQrTzOcwuFasRoH4ae7+uZqcJpRULwcLqxAuTMcxN0SGGQ36Oyikjb6yobu1Uum0xU/gsWnJ7noLDphdmgw2nvN5MkEcmWJTsTX8MT/k5DtgcRE73bruvMCaK4coHVuaE1iO+BlOTLxQ5k=");
                encryptedString = Convert.ToBase64String(encryptedBytes);
                Console.WriteLine("Original string: \"" + originalString + "\"");
                Console.WriteLine("Encrypted string (base-64): " + encryptedString);
                decryptedBytes = rsa.Decrypt(encryptedBytes, false);
                decryptedString = UtilCrypto.StringEncoding.GetString(decryptedBytes);
                Console.WriteLine("Decrypted string: \"" + decryptedString + "\"");
                Console.WriteLine(Environment.NewLine);
            }

            // Generate less PERSISTENT (because it may be deleted later) key (stored in key container):

            Console.Write(Environment.NewLine + "Generating a new (less) PERSISTENT RSA key...");
            alg = rsa = UtilCrypto.GetAsymmetricAlgorithm(Crypto.AsymmetricAlgorithmType.RSA, containerName)
                as RSACryptoServiceProvider;
            Console.WriteLine("  ... done. ");
            Console.WriteLine("Generated (less) PERSISTENT key: " + UtilCrypto.ToString(rsa));

            // Test encryption / decryption with the asymmetric keys:
            encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", alg, alg /* encryption same as decryption */);
            Console.WriteLine(Environment.NewLine + "Encryption / decryption test: "
                + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);


            // Export asymmetric keys to a file:
            if (saveKeys)
            {
                string filePath = "rsakeys_test_persistent.xml";
                Console.WriteLine("Saving RSA keys (including private) to " + filePath + " ...");
                string xmlString = alg.ToXmlString(true);
                xmlString = Util.XmlToString(xmlString, "  " /* indentChars */, Environment.NewLine /* newLineChars */);
                File.WriteAllText(filePath, xmlString);
                Console.WriteLine("rsakeys_test_less_persistent.xml" + Environment.NewLine);
            }


            // Store keys to XML:

            {
                Console.WriteLine(Environment.NewLine + "Storing key to XML string...");
                string xmlString = null;
                xmlString = alg.ToXmlString(true);
                xmlString = Util.XmlToString(xmlString);
                Console.WriteLine("XML represnetation of asymmetric keys: " + Environment.NewLine + xmlString);
                Console.WriteLine(Environment.NewLine + "... export to XML done successfully." + Environment.NewLine);
            }


            if (false)
            {
                Console.WriteLine(Environment.NewLine + Environment.NewLine + "DELETING key containerr named " + containerNameNoDelete + "...");
                UtilCrypto.DeleteKeyInCsp(AsymmetricAlgorithmType.RSA, containerNameNoDelete);
                Console.WriteLine(Environment.NewLine + "... RSA key deleted from key container named " + containerNameNoDelete + Environment.NewLine);
            }

            {
                // Certificate import: 
                X509Certificate2 cert = null;

                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Importing cert. IGLibTestCert.cer without password... ");
                cert = new X509Certificate2("IGLibTestCert.cer");
                if (cert == null)
                    Console.WriteLine(Environment.NewLine + "CERTIFICATE COULD NOT BE IMPORTED." + Environment.NewLine);
                else
                {
                    Console.WriteLine("... importing done." + Environment.NewLine + Environment.NewLine
                        + "Certificate: " + UtilCrypto.ToString(cert));
                    // Test encryption / decryption with the certificate's asymmetric keys:
                    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PublicKey.Key, cert.PrivateKey);
                    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test: "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);
                }

                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Importing cert. IGLibTestCert.cer WITH password... ");
                cert = new X509Certificate2("IGLibTestCert.cer", "IGLibPwd");
                if (cert == null)
                    Console.WriteLine(Environment.NewLine + "CERTIFICATE COULD NOT BE IMPORTED." + Environment.NewLine);
                else
                {
                    Console.WriteLine("... importing done." + Environment.NewLine + Environment.NewLine
                        + "Certificate: " + UtilCrypto.ToString(cert));
                    // Test encryption / decryption with the certificate's asymmetric keys:
                    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PublicKey.Key, cert.PrivateKey);
                    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test: "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);
                }


                //Console.WriteLine(Environment.NewLine + Environment.NewLine + "Importing cert. IGLibTestCert.pfx without password... ");
                //cert = new X509Certificate2("IGLibTestCert.pfx");
                //if (cert == null)
                //    Console.WriteLine(Environment.NewLine + "CERTIFICATE COULD NOT BE IMPORTED." + Environment.NewLine);
                //else
                //{
                //    Console.WriteLine("... importing done." + Environment.NewLine + Environment.NewLine
                //        + "Certificate: " + UtilCrypto.ToString(cert));
                //    // Test encryption / decryption with the certificate's asymmetric keys:
                //    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PublicKey.Key, cert.PrivateKey);
                //    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test: "
                //        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);
                //}

                Console.WriteLine(Environment.NewLine + Environment.NewLine + "Importing cert. IGLibTestCert.pfx WITH password... ");
                cert = new X509Certificate2("IGLibTestCert.pfx", "IGLibPwd");
                if (cert == null)
                    Console.WriteLine(Environment.NewLine + "CERTIFICATE COULD NOT BE IMPORTED." + Environment.NewLine);
                else
                {
                    Console.WriteLine("... importing done." + Environment.NewLine + Environment.NewLine
                        + "Certificate: " + UtilCrypto.ToString(cert));
                    // Test encryption / decryption with the certificate's asymmetric keys:
                    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PublicKey.Key, cert.PrivateKey);
                    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test: "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);

                    // Test encryption / decryption with the certificate's asymmetric keys:
                    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PrivateKey, cert.PrivateKey);
                    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test (ONLY PRIVATE keys): "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);

                    // Test encryption / decryption with the certificate's asymmetric keys:
                    encryptionTestPassed = UtilCrypto.AsymEncryptionDecryptionTest("Test String", cert.PublicKey.Key, cert.PublicKey.Key);
                    Console.WriteLine(Environment.NewLine + "Certificate Encryption / decryption test (ONLY PUBLIC keys): "
                        + (encryptionTestPassed ? "passed. " : "NOT passed.") + Environment.NewLine);

                    if (speedAndLengthTest || false)
                    {
                        int length1 = 3;
                        double factor = 1.555;
                        int maxLength = 30000;
                        bool doContinue = true;
                        StopWatch1 sw = new StopWatch1();
                        RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
                        while (doContinue)
                        {
                            byte[] orig = new Byte[length1];
                            byte[] encrypted = null;
                            byte[] decrypted = null;
                            rng.GetBytes(orig);
                            try
                            {
                                sw.Start();
                                encrypted = UtilCrypto.EncryptAsymShort(orig, cert.PrivateKey);
                                decrypted = UtilCrypto.DecryptAsymShort(encrypted, cert.PrivateKey);
                                sw.Stop();
                            }
                            catch (Exception ex) { Console.WriteLine("Encrypted/decrypted ERROR, length = " + length1 
                                + ", msg = " + ex.Message ); }
                            Console.WriteLine(Environment.NewLine + "Encrypt/decript, length = " + length1 + ": t = " +
                                sw.Time + " s");
                            bool equal = Util.AreEqual(orig, decrypted);
                            if (!equal)
                            {
                                Console.WriteLine("Encrypted/decrypted NOT EQUAL to original, length = " + length1);
                                doContinue = false;
                            }
                            length1 = (int)((double)length1 * factor);
                            if (length1 > maxLength)
                                doContinue = false;
                        }
                    }



                }


            }


            Console.WriteLine(Environment.NewLine + Environment.NewLine + "... asymmetric algorithm tests finished. " + Environment.NewLine);
            return ReturnedString;
        }  // AppAsymTest(...)


        #endregion Actions



        #region Tests


        #endregion Tests


    }  // class CryptoManager




}  // namespace IG.Crypto